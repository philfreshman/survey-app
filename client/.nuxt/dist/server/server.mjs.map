{"version":3,"mappings":"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EAAK3B,EAAKuN,EAAcC,IAAe,CAChE,GAAI,OAAO7L,EAAI3B,GAAS,KAAe,OAAOuN,GAAiB,WAC7D,SAAIvN,GAAOuN,EAAa5L,EAAI3B,EAAI,EACzB,EAEX,CAAC,ECnCKyN,GAAe,CAAE,EAIRH,GAAOG,EAAY,ECN3B,SAASC,GAAQC,EAAM,CAC5BnE,EAAY,EAAC,SAASmE,CAAI,CAC5B,CCAA,MAAMC,EAAa,CAAE,EAENC,KAAiB3E,GAAW,CACzC,UAAW4E,KAAQF,EACjB1E,EAAQ,OAAO,UAAU4E,EAAMF,EAAWE,EAAK,EAC/C5E,EAAQ,OAAO,UAAU,OAAS4E,EAAMF,EAAWE,EAAK,CAE5D,CAAC,ECiDD,eACA,qCACA,CCpDA,iBACAC,gBACAC,oBACAC,0BACAC,oBAOAC,OACA,WACA,oCACA,mBACA,SACA,QACAlO,SACAmO,6CACAC,SACA,CACA,sCACA,EACAC,MACA,oBACAC,mBACA,8DACA,EACAC,SACAC,UACA7F,4BACAA,oBACAA,EACA,EAEA8F,aACA,QACA,WACAC,KACA,SACA,oCACAC,mBACA,2CACA,wCACA,cACA,wCACA,qCACA,kBACA7E,uCACA8E,6BACAA,gBACAC,OACAD,yCACAE,mCACAC,2BACAL,aAEAM,aAEA,2DACA,CACA,eACA,mBACA,EACA,gBACA,WACA,eACA,sCACA,EACA,EACA,gBACA,WACA,eACA,sCACA,EACA,EACA,eACA,iBACA,CACA,CACA,EAGAC,WACA,YACA,MACA,yCACA,gCACA,cACA,WACA,SACA,WACA,uBACA,GACAL,kDACA,EACA,GACA,QACA,SACA,CACA,EACA,gBACA,EACAM,OACA,iCACA,wEACA,SACA,mCACA,kBACA,aACA,gBACA,kBACA,sBACA,eACAC,YACAtB,uCACA,iBACA,mBACA,0BAGA,yBACA,EACA,cACA,cACA,aACAuB,EAEA,iBACAA,SAEA,mBACA,mBACA,+BACArP,oBACA,UACA,CACAA,EACAsP,IACA,CACA,CACA,EAEAD,CACA,CACA,iBACA,MACA3M,SACA,SACA,MACA,SACA,SACA,YACA,EACA,SACA,YACA,CACA,EACA,uCACAA,OACAmM,mBACA,YAEA,GACA,mDACA,kBACAA,gBACA,YAEA,GACA,sCACA,kBACAA,kBACA,YAEA,IACA9E,6BACArH,UACAmM,UACAA,CACA,EACAU,MACA,mEACA,gCACA,UACA,YACA,oBACA,OACA,MACA,WACA,SACA,uBACA,iBACA,EACA,WACA,WACA,WACA,YACA,aACA,eACA,gBACA,gBACA,iBACA,QACA,QACA,CACA,EACA,wBAEAC,UACAC,QACAC,QACA,qBACAD,KACAA,6BAEAE,OACA,WACAnB,KACA,gBACAe,MACA,gBACAV,wBACAA,2BACAe,UACA,EACA,GACA,mFACA,gDACAC,kCACA,mBACA,WACAC,cACAA,aACA,EACAC,SACAD,+BAEAA,yBAEAA,wBACA,iBACA,WACAA,aACA,EACAC,UACAD,gBACAA,kBAEAA,wBAEA,CACA,QACA,EAGA,iBACA,uDACA,gCACA,gCACA,wBACA,kCACAE,UACAC,6BACA,CACA,CACA,uBACA,CACA,eACA,0BACA,KACA,4BACAjQ,QACAoM,qBAGA,WACA,kBACA,aACAnM,UAEAA,OACAmM,qBAEAA,oBACA8D,UACA,CACAA,SACA9D,8BAEAA,oBACA,EAGA+D,WACA,MACA,+BACA,iDACAC,QACAC,qCAEA,GACAxB,cACA9E,2BACA8E,mBACAwB,0BAEAA,wBAGAA,CACA,EAGAC,6BACA,QACA,eACAC,SACA,4CACA,sCACAC,wCACAC,KACAC,KACA,KACA,2BACAC,2DACAD,aAGA,KACA,mGACA1B,+DACAyB,eAGAG,0BACAA,0BACAA,8BACAC,YAEA,sBACA,MACA,OACA,gBACA,qDACA,CACA,GACAC,eACA,4BACA,aACA,mBACA,qBACA,EAEA,CACA,4BACA,aACA,mBACA,qBACA,EAEA,CACA,QACA,GACAJ,cACA,MACA,oDACA,GACAD,cACA,MACA,oDACA,GACAK,cACAC,OACAR,+CAEAM,2BACA,GACAD,eACA,UACA,2CACA,CACA,EAGAI,kBACA,QACA,WACAC,IACAA,mBACA,qCACA,yCACA,OAEA,yBACA,2CACA,wCACA,cACA,wCACA,qCACA,iBACA,cACA,YACA,wBACAA,oBACA,MACA,WACA,WACA,WACA,YACA,aACA,eACAC,sBACAA,iBACA,KACA,CAEAC,oFACAA,yEACA,0CACA,iBACAb,iBACAc,UACA,mCACA,EAuDAC,oBA+EA,WACA,SACAC,IACA,gBACA,WACA,SACA,WACAC,4BACAA,mCACAA,eACA,EACA,OACA,gBACA,mBACA,qBACA,EACA,kBACA,QACA,EACA,eACA,yBACA,YACA,EACA,iBACA,sBACA,EACA,iBACA,SACAnR,sBACAoR,KACA,mBAEA,SACA,OACA,UACA,WACA,OACA,EACA,iBACA,CACA,SACA/C,0BACA,EACA,UACAA,YACA7F,cACAA,WACAA,EACA,CACA,CACA,CACA,EACA,qBACA,aACA6I,OACAT,WAEA,SACAU,IACAD,mCACA,EACA,yBACA,WACA,gBACA,aACAE,SACAA,aACAC,EACA,kBACA,EAEAD,WAIA,GACA,WACAE,IACAF,GACAA,UACA,CACA,CACA,EACA,UACAd,cACAA,CACA,EC3oBO,MAAMiB,GAAU,CAAC,KAAO,CAAC,CAAC,QAAU,OAAO,EAAE,CAAC,KAAO,SAAS,QAAU,gBAAgB,EAAE,CAAC,KAAO,WAAW,QAAU,gCAAgC,EAAE,CAAC,KAAO,WAAW,QAAU,qCAAqC,CAAC,EAAE,KAAO,CAAC,CAAC,IAAM,OAAO,KAAO,eAAe,KAAO,wBAAwB,CAAC,EAAE,MAAQ,GAAG,OAAS,GAAG,SAAW,CAAE,EAAC,MAAQ,YAAY,cAAgB,qBAAqB,EAQpYC,GAAoB,GAEpBC,GAAe,GCR5BC,SACA,aACApB,6BACA3H,gBAkBAA,mBACA,CACA2H,gBACA,MACA,CAUA,EAEA3H,kCACA,oBACA,OACA,KACA,sBACA,CACA,CAEA,GC9CMgJ,GAAY,CAChB,SAAU,CACR,MAAMzK,EAAWkC,KACjB,GAAI,CAAClC,EACH,OAEF,MAAMrH,EAAUqH,EAAS,KACzB,GAAI,CAACrH,GAAW,EAAE,SAAUA,GAC1B,OAEF,MAAM8I,EAAUM,IACV2I,EA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sBACd,CACH,CAAC,EACYC,GAAU,CAACC,EAAWzJ,EAAOI,KACjC,CAAE,QAAS,IAAMJ,EAAQQ,EAAEiJ,EAAWzJ,IAAU,GAAO,CAAE,EAAGA,EAAOI,CAAK,EAAII,EAAE6I,GAAU,CAAE,EAAEjJ,CAAK,ICA1GkJ,GACA,gBACA,gBACA,OACA,MACA,WACA,EACA,YACA,sBACA,cACA,EACA,WACA,sBACA,cACA,EACA,OACA,WACA,EACA,SACA,uBACA,YACA,CACA,EACA,mBACA,YACA,UACA9I,uCACA,wBACA,gBACA,OAEA,wBACAkJ,qBACAC,0EACAC,SACA5J,aACAiJ,4BACAY,GACA,mBACA7M,gDACA,EACA,mBACA,UACA8M,GACAH,KACAR,IACA3C,6DACAhG,MACA,mDACA,eACAkH,wDACA,CACA,qEACA,CACA,WACA,CACA,EAEA,CACA,GACA,eACA,kCACA,CACA,eACA,mBACA,KACA,+BACA,IACA,eACA,CACA,YACA,+CACA,SACA,kBACAc,qBACAG,KACA,kCACAA,qDAEA,yBAYA,IAKAnI,yBAEA,CACA,GClGK,WAAW,SACd,WAAW,OAAS5F,GAAO,OAAO,CAChC,QAASM,GAAS,CACtB,CAAG,GAGa2B,GAAiBC,EAAQ","names":["suspectProtoRx","suspectConstructorRx","JsonSigRx","jsonParseTransform","key","value","destr","val","options","_lval","error","HASH_RE","AMPERSAND_RE","EQUAL_RE","PLUS_RE","ENC_BRACKET_OPEN_RE","ENC_BRACKET_CLOSE_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_CURLY_OPEN_RE","ENC_PIPE_RE","ENC_CURLY_CLOSE_RE","ENC_SPACE_RE","encode","text","encodeQueryValue","encodeQueryKey","decode","decodeQueryValue","parseQuery","paramsStr","obj","param","s","encodeQueryItem","_val","stringifyQuery","query","k","PROTOCOL_REGEX","PROTOCOL_RELATIVE_REGEX","hasProtocol","inputStr","acceptProtocolRelative","TRAILING_SLASH_RE","hasTrailingSlash","input","queryParams","withoutTrailingSlash","s0","withTrailingSlash","hasLeadingSlash","withoutLeadingSlash","withLeadingSlash","withBase","base","isEmptyURL","_base","joinURL","withQuery","parsed","parseURL","mergedQuery","stringifyParsedURL","url","isNonEmptyURL","i","isEqual","a","b","opts","defaultProto","parsePath","protocol","auth","hostAndPath","host","path","pathname","search","hash","fullpath","FetchError","createFetchError","request","response","message","fetchError","payloadMethods","isPayloadMethod","method","isJSONSerializable","textTypes","JSON_RE","detectResponseType","_contentType","contentType","retryStatusCodes","createFetch","globalOptions","onError","ctx","isAbort","retries","responseCode","$fetchRaw","err","_request","_opts","Headers","fetch","responseType","data","parseFn","$fetch","r","defaultOptions","_globalThis","appConfig","useRuntimeConfig","baseURL","createContext","currentInstance","isSingleton","checkConflict","instance","replace","cb","onRestore","onLeave","asyncHandlers","createNamespace","contexts","globalKey","defaultNamespace","getContext","asyncHandlersKey","executeAsync","fn","restores","leaveHandler","restore2","restore","awaitable","e","nuxtAppCtx","NuxtPluginIndicator","normalizePlugins","_plugins","plugin","nuxtApp","defineNuxtPlugin","callWithNuxt","nuxt","setup","args","useNuxtApp","nuxtAppInstance","vm","getCurrentInstance","H3Error","createError","isError","_a","MIMES","defer","send","event","type","defaultContentType","resolve","sendRedirect","location","code","html","useError","toRef","showError","_err","_createError","useState","autoKey","_key","init","state","initialValue","isRef","useRouter","defineNuxtRouteMiddleware","middleware","navigateTo","to","toPath","isExternal","router","redirectLocation","firstNonUndefined","DEFAULT_EXTERNAL_REL_ATTRIBUTE","props","prefetched","el","resolveComponent","slots","target","rel","navigate","h","defineNuxtLink","isObject","_defu","baseObj","defaults","namespace","merger","createDefu","p","c","defu","defuFn","currentValue","_namespace","inlineConfig","useHead","meta","components","_nuxt_components_plugin_mjs_KR1HBZs4kY","name","HEAD_COUNT_KEY","HEAD_ATTRS_KEY","SELF_CLOSING_TAGS","BODY_TAG_ATTR_NAME","propsToString","attribute","handledAttributes","tagToString","openTag","resolveHeadEntries","entries","renderHeadToString","bodyHtml","resolvedEntries","tag","titleHtml","attrs","_b","headHtml","sortTags","tagDedupeKey","tagName","root","resolveUnrefHeadInput","headInputToTags","renderTitleTemplate","template","title","resolveHeadEntriesToTags","deduping","titleIdx","resolvedTags","newTitle","cloneTag","nonce","keys","createElement","v","$el","updateElements","body","headCount","oldHeadElements","oldBodyElements","bodyMetaElements","headCountEl","head","newElements","t","updateDOM","document","tags","setAttrs","previousTags","version","entryId","app","resolved","domUpdateTick","doDomUpdate","entrySideEffect","resolvedInput","cleanUpWatch","appHead","appPageTransition","appKeepalive","node_modules_nuxt_dist_head_runtime_lib_vueuse_head_plugin_mjs_D7WGfuP1A0","metaMixin","source","node_modules_nuxt_dist_head_runtime_mixin_plugin_mjs_prWV5EzJWI","_routes","_47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47index_46vueMeta","__vitePreload","m","_c","_d","_47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47login_46vueMeta","_e","_f","_47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47logout_46vueMeta","_g","_h","_47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47register_46vueMeta","_i","_j","_47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47unauthorized_46vueMeta","routerOptions0","from","savedPosition","position","_isDifferentRoute","_getHashElementScrollMarginTop","hookToWait","nextTick","selector","elem","samePageComponent","configRouterOptions","routerOptions","validate","result","globalMiddleware","namedMiddleware","node_modules_nuxt_dist_pages_runtime_router_mjs_qNv5Ky2ZmB","routerBase","routes","initialURL","previousRoute","syncCurrentRoute","_route","route","middlewareEntries","interpolatePath","match","generateRouteKey","override","routeProps","matchedRoute","wrapInKeepAlive","children","Fragment","defineComponent","_props","_wrapIf","component","done","hasTransition","transitionProps","defaultPageTransition","Transition"],"sources":["../../../node_modules/destr/dist/index.mjs","../../../node_modules/ufo/dist/index.mjs","../../../node_modules/ohmyfetch/dist/shared/ohmyfetch.d1948a88.mjs","../../../node_modules/ohmyfetch/dist/index.mjs","../../../virtual:nuxt:/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/.nuxt/paths.mjs","../../../node_modules/unctx/dist/index.mjs","../../../node_modules/nuxt/dist/app/nuxt.mjs","../../../node_modules/h3/dist/index.mjs","../../../node_modules/nuxt/dist/app/composables/error.mjs","../../../node_modules/nuxt/dist/app/composables/state.mjs","../../../node_modules/nuxt/dist/app/composables/router.mjs","../../../node_modules/nuxt/dist/app/components/nuxt-link.mjs","../../../node_modules/defu/dist/defu.mjs","../../app.config.mjs","../../../node_modules/nuxt/dist/head/runtime/composables.mjs","../../../virtual:nuxt:/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/.nuxt/components.plugin.mjs","../../../node_modules/@vueuse/shared/index.mjs","../../../node_modules/@vueuse/head/dist/index.mjs","../../../virtual:nuxt:/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/.nuxt/nuxt.config.mjs","../../../node_modules/nuxt/dist/head/runtime/lib/vueuse-head.plugin.mjs","../../../node_modules/nuxt/dist/head/runtime/mixin-plugin.mjs","../../../virtual:nuxt:/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/.nuxt/routes.mjs","../../../node_modules/nuxt/dist/pages/runtime/router.options.mjs","../../../virtual:nuxt:/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/.nuxt/router.options.mjs","../../../node_modules/nuxt/dist/pages/runtime/validate.mjs","../../../virtual:nuxt:/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/.nuxt/middleware.mjs","../../../node_modules/nuxt/dist/pages/runtime/router.mjs","../../../virtual:nuxt:/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/.nuxt/plugins/server.mjs","../../../node_modules/nuxt/dist/pages/runtime/utils.mjs","../../../node_modules/nuxt/dist/app/components/utils.mjs","../../../node_modules/nuxt/dist/pages/runtime/page.mjs","../../../node_modules/nuxt/dist/app/entry.mjs"],"sourcesContent":["const suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/;\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\nconst JsonSigRx = /^[\"{[]|^-?[0-9][0-9.]{0,14}$/;\nfunction jsonParseTransform(key, value) {\n  if (key === \"__proto__\" || key === \"constructor\") {\n    return;\n  }\n  return value;\n}\nfunction destr(val, options = {}) {\n  if (typeof val !== \"string\") {\n    return val;\n  }\n  const _lval = val.toLowerCase();\n  if (_lval === \"true\") {\n    return true;\n  }\n  if (_lval === \"false\") {\n    return false;\n  }\n  if (_lval === \"null\") {\n    return null;\n  }\n  if (_lval === \"nan\") {\n    return NaN;\n  }\n  if (_lval === \"infinity\") {\n    return Infinity;\n  }\n  if (_lval === \"undefined\") {\n    return void 0;\n  }\n  if (!JsonSigRx.test(val)) {\n    if (options.strict) {\n      throw new SyntaxError(\"Invalid JSON\");\n    }\n    return val;\n  }\n  try {\n    if (suspectProtoRx.test(val) || suspectConstructorRx.test(val)) {\n      return JSON.parse(val, jsonParseTransform);\n    }\n    return JSON.parse(val);\n  } catch (error) {\n    if (options.strict) {\n      throw error;\n    }\n    return val;\n  }\n}\n\nexport { destr as default };\n","const n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = { overflow: \"Overflow Error\", \"not-basic\": \"Illegal Input\", \"invalid-input\": \"Invalid Input\" };\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_BRACKET_OPEN_RE = /%5B/gi;\nconst ENC_BRACKET_CLOSE_RE = /%5D/gi;\nconst ENC_CARET_RE = /%5E/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7B/gi;\nconst ENC_PIPE_RE = /%7C/gi;\nconst ENC_CURLY_CLOSE_RE = /%7D/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2F/gi;\nconst ENC_ENC_SLASH_RE = /%252F/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\").replace(ENC_BRACKET_OPEN_RE, \"[\").replace(ENC_BRACKET_CLOSE_RE, \"]\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(text) {\n  return encode(text).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch (_err) {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(paramsStr = \"\") {\n  const obj = {};\n  if (paramsStr[0] === \"?\") {\n    paramsStr = paramsStr.substr(1);\n  }\n  for (const param of paramsStr.split(\"&\")) {\n    const s = param.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decode(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (obj[key]) {\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value);\n      } else {\n        obj[key] = [obj[key], value];\n      }\n    } else {\n      obj[key] = value;\n    }\n  }\n  return obj;\n}\nfunction encodeQueryItem(key, val) {\n  if (typeof val === \"number\" || typeof val === \"boolean\") {\n    val = String(val);\n  }\n  if (!val) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(val)) {\n    return val.map((_val) => `${encodeQueryKey(key)}=${encodeQueryValue(_val)}`).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(val)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).map((k) => encodeQueryItem(k, query[k])).join(\"&\");\n}\n\nclass $URL {\n  constructor(input = \"\") {\n    this.query = {};\n    if (typeof input !== \"string\") {\n      throw new TypeError(`URL input should be string received ${typeof input} (${input})`);\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        value.forEach((v) => p.append(name, v));\n      } else {\n        p.append(name, value || \"\");\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\n\nfunction isRelative(inputStr) {\n  return [\"./\", \"../\"].some((str) => inputStr.startsWith(str));\n}\nconst PROTOCOL_REGEX = /^\\w+:(\\/\\/)?/;\nconst PROTOCOL_RELATIVE_REGEX = /^\\/\\/[^/]+/;\nfunction hasProtocol(inputStr, acceptProtocolRelative = false) {\n  return PROTOCOL_REGEX.test(inputStr) || acceptProtocolRelative && PROTOCOL_RELATIVE_REGEX.test(inputStr);\n}\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?/;\nfunction hasTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return (s0.slice(0, -1) || \"/\") + (s.length ? `?${s.join(\"?\")}` : \"\");\n}\nfunction withTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return s0 + \"/\" + (s.length ? `?${s.join(\"?\")}` : \"\");\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.substr(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((str) => str.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base) || hasProtocol(input)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (!input.startsWith(_base)) {\n    return input;\n  }\n  const trimmed = input.substring(_base.length);\n  return trimmed[0] === \"/\" ? trimmed : \"/\" + trimmed;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const i of input.filter(isNonEmptyURL)) {\n    url = url ? withTrailingSlash(url) + withoutLeadingSlash(i) : i;\n  }\n  return url;\n}\nfunction withHttp(input) {\n  return withProtocol(input, \"http://\");\n}\nfunction withHttps(input) {\n  return withProtocol(input, \"https://\");\n}\nfunction withoutProtocol(input) {\n  return withProtocol(input, \"\");\n}\nfunction withProtocol(input, protocol) {\n  const match = input.match(PROTOCOL_REGEX);\n  if (!match) {\n    return protocol + input;\n  }\n  return protocol + input.substring(match[0].length);\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\nfunction normalizeURL(input) {\n  return createURL(input).toString();\n}\nfunction resolveURL(base, ...input) {\n  const url = createURL(base);\n  for (const i of input.filter(isNonEmptyURL)) {\n    url.append(createURL(i));\n  }\n  return url.toString();\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\nfunction isEqual(a, b, opts = {}) {\n  if (!opts.trailingSlash) {\n    a = withTrailingSlash(a);\n    b = withTrailingSlash(b);\n  }\n  if (!opts.leadingSlash) {\n    a = withLeadingSlash(a);\n    b = withLeadingSlash(b);\n  }\n  if (!opts.encoding) {\n    a = decode(a);\n    b = decode(b);\n  }\n  return a === b;\n}\n\nfunction parseURL(input = \"\", defaultProto) {\n  if (!hasProtocol(input, true)) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [protocol = \"\", auth, hostAndPath = \"\"] = (input.replace(/\\\\/g, \"/\").match(/([^:/]+:)?\\/\\/([^/@]+@)?(.*)/) || []).splice(1);\n  const [host = \"\", path = \"\"] = (hostAndPath.match(/([^/?#]*)(.*)?/) || []).splice(1);\n  const { pathname, search, hash } = parsePath(path);\n  return {\n    protocol,\n    auth: auth ? auth.substr(0, auth.length - 1) : \"\",\n    host,\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/]*)(:0-9+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const fullpath = parsed.pathname + (parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\") + parsed.hash;\n  if (!parsed.protocol) {\n    return fullpath;\n  }\n  return parsed.protocol + \"//\" + (parsed.auth ? parsed.auth + \"@\" : \"\") + parsed.host + fullpath;\n}\n\nexport { $URL, cleanDoubleSlashes, createURL, decode, decodePath, decodeQueryValue, encode, encodeHash, encodeHost, encodeParam, encodePath, encodeQueryItem, encodeQueryKey, encodeQueryValue, getQuery, hasLeadingSlash, hasProtocol, hasTrailingSlash, isEmptyURL, isEqual, isNonEmptyURL, isRelative, isSamePath, joinURL, normalizeURL, parseAuth, parseHost, parsePath, parseQuery, parseURL, resolveURL, stringifyParsedURL, stringifyQuery, withBase, withHttp, withHttps, withLeadingSlash, withProtocol, withQuery, withTrailingSlash, withoutBase, withoutLeadingSlash, withoutProtocol, withoutTrailingSlash };\n","import destr from 'destr';\nimport { withBase, withQuery } from 'ufo';\n\nclass FetchError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"FetchError\";\n  }\n}\nfunction createFetchError(request, error, response) {\n  let message = \"\";\n  if (request && response) {\n    message = `${response.status} ${response.statusText} (${request.toString()})`;\n  }\n  if (error) {\n    message = `${error.message} (${message})`;\n  }\n  const fetchError = new FetchError(message);\n  Object.defineProperty(fetchError, \"request\", { get() {\n    return request;\n  } });\n  Object.defineProperty(fetchError, \"response\", { get() {\n    return response;\n  } });\n  Object.defineProperty(fetchError, \"data\", { get() {\n    return response && response._data;\n  } });\n  Object.defineProperty(fetchError, \"status\", { get() {\n    return response && response.status;\n  } });\n  Object.defineProperty(fetchError, \"statusText\", { get() {\n    return response && response.statusText;\n  } });\n  Object.defineProperty(fetchError, \"statusCode\", { get() {\n    return response && response.status;\n  } });\n  Object.defineProperty(fetchError, \"statusMessage\", { get() {\n    return response && response.statusText;\n  } });\n  return fetchError;\n}\n\nconst payloadMethods = new Set(Object.freeze([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"]));\nfunction isPayloadMethod(method = \"GET\") {\n  return payloadMethods.has(method.toUpperCase());\n}\nfunction isJSONSerializable(val) {\n  if (val === void 0) {\n    return false;\n  }\n  const t = typeof val;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(val)) {\n    return true;\n  }\n  return val.constructor && val.constructor.name === \"Object\" || typeof val.toJSON === \"function\";\n}\nconst textTypes = /* @__PURE__ */ new Set([\n  \"image/svg\",\n  \"application/xml\",\n  \"application/xhtml\",\n  \"application/html\"\n]);\nconst JSON_RE = /^application\\/(?:[\\w!#$%&*`\\-.^~]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(_contentType = \"\") {\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift();\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\n\nconst retryStatusCodes = /* @__PURE__ */ new Set([\n  408,\n  409,\n  425,\n  429,\n  500,\n  502,\n  503,\n  504\n]);\nfunction createFetch(globalOptions) {\n  const { fetch, Headers } = globalOptions;\n  function onError(ctx) {\n    const isAbort = ctx.error && ctx.error.name === \"AbortError\" || false;\n    if (ctx.options.retry !== false && !isAbort) {\n      const retries = typeof ctx.options.retry === \"number\" ? ctx.options.retry : isPayloadMethod(ctx.options.method) ? 0 : 1;\n      const responseCode = ctx.response && ctx.response.status || 500;\n      if (retries > 0 && retryStatusCodes.has(responseCode)) {\n        return $fetchRaw(ctx.request, {\n          ...ctx.options,\n          retry: retries - 1\n        });\n      }\n    }\n    const err = createFetchError(ctx.request, ctx.error, ctx.response);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(err, $fetchRaw);\n    }\n    throw err;\n  }\n  const $fetchRaw = async function $fetchRaw2(_request, _opts = {}) {\n    const ctx = {\n      request: _request,\n      options: { ...globalOptions.defaults, ..._opts },\n      response: void 0,\n      error: void 0\n    };\n    if (ctx.options.onRequest) {\n      await ctx.options.onRequest(ctx);\n    }\n    if (typeof ctx.request === \"string\") {\n      if (ctx.options.baseURL) {\n        ctx.request = withBase(ctx.request, ctx.options.baseURL);\n      }\n      if (ctx.options.query || ctx.options.params) {\n        ctx.request = withQuery(ctx.request, { ...ctx.options.params, ...ctx.options.query });\n      }\n      if (ctx.options.body && isPayloadMethod(ctx.options.method)) {\n        if (isJSONSerializable(ctx.options.body)) {\n          ctx.options.body = typeof ctx.options.body === \"string\" ? ctx.options.body : JSON.stringify(ctx.options.body);\n          ctx.options.headers = new Headers(ctx.options.headers);\n          if (!ctx.options.headers.has(\"content-type\")) {\n            ctx.options.headers.set(\"content-type\", \"application/json\");\n          }\n          if (!ctx.options.headers.has(\"accept\")) {\n            ctx.options.headers.set(\"accept\", \"application/json\");\n          }\n        }\n      }\n    }\n    ctx.response = await fetch(ctx.request, ctx.options).catch(async (error) => {\n      ctx.error = error;\n      if (ctx.options.onRequestError) {\n        await ctx.options.onRequestError(ctx);\n      }\n      return onError(ctx);\n    });\n    const responseType = (ctx.options.parseResponse ? \"json\" : ctx.options.responseType) || detectResponseType(ctx.response.headers.get(\"content-type\") || \"\");\n    if (responseType === \"json\") {\n      const data = await ctx.response.text();\n      const parseFn = ctx.options.parseResponse || destr;\n      ctx.response._data = parseFn(data);\n    } else if (responseType === \"stream\") {\n      ctx.response._data = ctx.response.body;\n    } else {\n      ctx.response._data = await ctx.response[responseType]();\n    }\n    if (ctx.options.onResponse) {\n      await ctx.options.onResponse(ctx);\n    }\n    if (ctx.response.status >= 400 && ctx.response.status < 600) {\n      if (ctx.options.onResponseError) {\n        await ctx.options.onResponseError(ctx);\n      }\n      return onError(ctx);\n    }\n    return ctx.response;\n  };\n  const $fetch = function $fetch2(request, opts) {\n    return $fetchRaw(request, opts).then((r) => r._data);\n  };\n  $fetch.raw = $fetchRaw;\n  $fetch.create = (defaultOptions = {}) => createFetch({\n    ...globalOptions,\n    defaults: {\n      ...globalOptions.defaults,\n      ...defaultOptions\n    }\n  });\n  return $fetch;\n}\n\nexport { FetchError as F, createFetchError as a, createFetch as c };\n","import { c as createFetch } from './shared/ohmyfetch.d1948a88.mjs';\nexport { F as FetchError, c as createFetch, a as createFetchError } from './shared/ohmyfetch.d1948a88.mjs';\nimport 'destr';\nimport 'ufo';\n\nconst _globalThis = function() {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"unable to locate global object\");\n}();\nconst fetch = _globalThis.fetch || (() => Promise.reject(new Error(\"[ohmyfetch] global.fetch is not supported!\")));\nconst Headers = _globalThis.Headers;\nconst $fetch = createFetch({ fetch, Headers });\n\nexport { $fetch, Headers, fetch };\n","import { joinURL } from '/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/node_modules/ufo/dist/index.mjs'\nimport { useRuntimeConfig } from '#internal/nitro'\nconst appConfig = useRuntimeConfig().app\nexport const baseURL = () => appConfig.baseURL\nexport const buildAssetsDir = () => appConfig.buildAssetsDir\nexport const buildAssetsURL = (...path) => joinURL(publicAssetsURL(), buildAssetsDir(), ...path)\nexport const publicAssetsURL = (...path) => {\n  const publicBase = appConfig.cdnURL || appConfig.baseURL\n  return path.length ? joinURL(publicBase, ...path) : publicBase\n}\nif (process.client) {\n  globalThis.__buildAssetsURL = buildAssetsURL\n  globalThis.__publicAssetsURL = publicAssetsURL\n}","function createContext() {\n  let currentInstance = null;\n  let isSingleton = false;\n  const checkConflict = (instance) => {\n    if (currentInstance && currentInstance !== instance) {\n      throw new Error(\"Context conflict\");\n    }\n  };\n  return {\n    use: () => {\n      if (currentInstance == null) {\n        throw new Error(\"Context is not available\");\n      }\n      return currentInstance;\n    },\n    tryUse: () => {\n      return currentInstance;\n    },\n    set: (instance, replace) => {\n      if (!replace) {\n        checkConflict(instance);\n      }\n      currentInstance = instance;\n      isSingleton = true;\n    },\n    unset: () => {\n      currentInstance = null;\n      isSingleton = false;\n    },\n    call: (instance, cb) => {\n      checkConflict(instance);\n      currentInstance = instance;\n      try {\n        return cb();\n      } finally {\n        if (!isSingleton) {\n          currentInstance = null;\n        }\n      }\n    },\n    async callAsync(instance, cb) {\n      currentInstance = instance;\n      const onRestore = () => {\n        currentInstance = instance;\n      };\n      const onLeave = () => currentInstance === instance ? onRestore : void 0;\n      asyncHandlers.add(onLeave);\n      try {\n        const r = cb();\n        if (!isSingleton) {\n          currentInstance = null;\n        }\n        return await r;\n      } finally {\n        asyncHandlers.delete(onLeave);\n      }\n    }\n  };\n}\nfunction createNamespace() {\n  const contexts = {};\n  return {\n    get(key) {\n      if (!contexts[key]) {\n        contexts[key] = createContext();\n      }\n      contexts[key];\n      return contexts[key];\n    }\n  };\n}\nconst _globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : {};\nconst globalKey = \"__unctx__\";\nconst defaultNamespace = _globalThis[globalKey] || (_globalThis[globalKey] = createNamespace());\nconst getContext = (key) => defaultNamespace.get(key);\nconst useContext = (key) => getContext(key).use;\nconst asyncHandlersKey = \"__unctx_async_handlers__\";\nconst asyncHandlers = _globalThis[asyncHandlersKey] || (_globalThis[asyncHandlersKey] = /* @__PURE__ */ new Set());\nfunction executeAsync(fn) {\n  const restores = [];\n  for (const leaveHandler of asyncHandlers) {\n    const restore2 = leaveHandler();\n    if (restore2) {\n      restores.push(restore2);\n    }\n  }\n  const restore = () => {\n    for (const restore2 of restores) {\n      restore2();\n    }\n  };\n  let awaitable = fn();\n  if (\"catch\" in awaitable) {\n    awaitable = awaitable.catch((e) => {\n      restore();\n      throw e;\n    });\n  }\n  return [awaitable, restore];\n}\nfunction withAsyncContext(fn, transformed) {\n  if (!transformed) {\n    console.warn(\"[unctx] `withAsyncContext` needs transformation for async context support in\", fn, \"\\n\", fn.toString());\n  }\n  return fn;\n}\n\nexport { createContext, createNamespace, defaultNamespace, executeAsync, getContext, useContext, withAsyncContext };\n","import { getCurrentInstance, reactive } from \"vue\";\nimport { createHooks } from \"hookable\";\nimport { getContext } from \"unctx\";\nconst nuxtAppCtx = getContext(\"nuxt-app\");\nexport const NuxtPluginIndicator = \"__nuxt_plugin\";\nexport function createNuxtApp(options) {\n  let hydratingCount = 0;\n  const nuxtApp = {\n    provide: void 0,\n    globalName: \"nuxt\",\n    payload: reactive({\n      data: {},\n      state: {},\n      _errors: {},\n      ...process.client ? window.__NUXT__ : { serverRendered: true }\n    }),\n    isHydrating: process.client,\n    deferHydration() {\n      if (!nuxtApp.isHydrating) {\n        return () => {\n        };\n      }\n      hydratingCount++;\n      let called = false;\n      return () => {\n        if (called) {\n          return;\n        }\n        called = true;\n        hydratingCount--;\n        if (hydratingCount === 0) {\n          nuxtApp.isHydrating = false;\n          return nuxtApp.callHook(\"app:suspense:resolve\");\n        }\n      };\n    },\n    _asyncDataPromises: {},\n    _asyncData: {},\n    ...options\n  };\n  nuxtApp.hooks = createHooks();\n  nuxtApp.hook = nuxtApp.hooks.hook;\n  nuxtApp.callHook = nuxtApp.hooks.callHook;\n  nuxtApp.provide = (name, value) => {\n    const $name = \"$\" + name;\n    defineGetter(nuxtApp, $name, value);\n    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value);\n  };\n  defineGetter(nuxtApp.vueApp, \"$nuxt\", nuxtApp);\n  defineGetter(nuxtApp.vueApp.config.globalProperties, \"$nuxt\", nuxtApp);\n  if (process.server) {\n    if (nuxtApp.ssrContext) {\n      nuxtApp.ssrContext.nuxt = nuxtApp;\n    }\n    nuxtApp.ssrContext = nuxtApp.ssrContext || {};\n    if (nuxtApp.ssrContext.payload) {\n      Object.assign(nuxtApp.payload, nuxtApp.ssrContext.payload);\n    }\n    nuxtApp.ssrContext.payload = nuxtApp.payload;\n    nuxtApp.payload.config = {\n      public: options.ssrContext.runtimeConfig.public,\n      app: options.ssrContext.runtimeConfig.app\n    };\n  }\n  const runtimeConfig = process.server ? options.ssrContext.runtimeConfig : reactive(nuxtApp.payload.config);\n  const compatibilityConfig = new Proxy(runtimeConfig, {\n    get(target, prop) {\n      if (prop === \"public\") {\n        return target.public;\n      }\n      return target[prop] ?? target.public[prop];\n    },\n    set(target, prop, value) {\n      if (process.server || prop === \"public\" || prop === \"app\") {\n        return false;\n      }\n      target[prop] = value;\n      target.public[prop] = value;\n      return true;\n    }\n  });\n  nuxtApp.provide(\"config\", compatibilityConfig);\n  return nuxtApp;\n}\nexport async function applyPlugin(nuxtApp, plugin) {\n  if (typeof plugin !== \"function\") {\n    return;\n  }\n  const { provide } = await callWithNuxt(nuxtApp, plugin, [nuxtApp]) || {};\n  if (provide && typeof provide === \"object\") {\n    for (const key in provide) {\n      nuxtApp.provide(key, provide[key]);\n    }\n  }\n}\nexport async function applyPlugins(nuxtApp, plugins) {\n  for (const plugin of plugins) {\n    await applyPlugin(nuxtApp, plugin);\n  }\n}\nexport function normalizePlugins(_plugins) {\n  const unwrappedPlugins = [];\n  const legacyInjectPlugins = [];\n  const invalidPlugins = [];\n  const plugins = _plugins.map((plugin) => {\n    if (typeof plugin !== \"function\") {\n      invalidPlugins.push(plugin);\n      return null;\n    }\n    if (plugin.length > 1) {\n      legacyInjectPlugins.push(plugin);\n      return (nuxtApp) => plugin(nuxtApp, nuxtApp.provide);\n    }\n    if (!isNuxtPlugin(plugin)) {\n      unwrappedPlugins.push(plugin);\n    }\n    return plugin;\n  }).filter(Boolean);\n  if (process.dev && legacyInjectPlugins.length) {\n    console.warn(\"[warn] [nuxt] You are using a plugin with legacy Nuxt 2 format (context, inject) which is likely to be broken. In the future they will be ignored:\", legacyInjectPlugins.map((p) => p.name || p).join(\",\"));\n  }\n  if (process.dev && invalidPlugins.length) {\n    console.warn(\"[warn] [nuxt] Some plugins are not exposing a function and skipped:\", invalidPlugins);\n  }\n  if (process.dev && unwrappedPlugins.length) {\n    console.warn(\"[warn] [nuxt] You are using a plugin that has not been wrapped in `defineNuxtPlugin`. It is advised to wrap your plugins as in the future this may enable enhancements:\", unwrappedPlugins.map((p) => p.name || p).join(\",\"));\n  }\n  return plugins;\n}\nexport function defineNuxtPlugin(plugin) {\n  plugin[NuxtPluginIndicator] = true;\n  return plugin;\n}\nexport function isNuxtPlugin(plugin) {\n  return typeof plugin === \"function\" && NuxtPluginIndicator in plugin;\n}\nexport function callWithNuxt(nuxt, setup, args) {\n  const fn = () => args ? setup(...args) : setup();\n  if (process.server) {\n    return nuxtAppCtx.callAsync(nuxt, fn);\n  } else {\n    nuxtAppCtx.set(nuxt);\n    return fn();\n  }\n}\nexport function useNuxtApp() {\n  const nuxtAppInstance = nuxtAppCtx.tryUse();\n  if (!nuxtAppInstance) {\n    const vm = getCurrentInstance();\n    if (!vm) {\n      throw new Error(\"nuxt instance unavailable\");\n    }\n    return vm.appContext.app.$nuxt;\n  }\n  return nuxtAppInstance;\n}\nexport function useRuntimeConfig() {\n  return useNuxtApp().$config;\n}\nfunction defineGetter(obj, key, val) {\n  Object.defineProperty(obj, key, { get: () => val });\n}\nexport function defineAppConfig(config) {\n  return config;\n}\n","import { withoutTrailingSlash, withoutBase, getQuery as getQuery$1 } from 'ufo';\nimport { createRouter as createRouter$1 } from 'radix3';\nimport destr from 'destr';\nimport { parse, serialize } from 'cookie-es';\n\nfunction useBase(base, handler) {\n  base = withoutTrailingSlash(base);\n  if (!base) {\n    return handler;\n  }\n  return eventHandler((event) => {\n    event.req.originalUrl = event.req.originalUrl || event.req.url || \"/\";\n    event.req.url = withoutBase(event.req.url || \"/\", base);\n    return handler(event);\n  });\n}\n\nclass H3Error extends Error {\n  constructor() {\n    super(...arguments);\n    this.statusCode = 500;\n    this.fatal = false;\n    this.unhandled = false;\n    this.statusMessage = void 0;\n  }\n  toJSON() {\n    const obj = {\n      message: this.message,\n      statusCode: this.statusCode\n    };\n    if (this.statusMessage) {\n      obj.statusMessage = this.statusMessage;\n    }\n    if (this.data !== void 0) {\n      obj.data = this.data;\n    }\n    return obj;\n  }\n}\nH3Error.__h3_error__ = true;\nfunction createError(input) {\n  if (typeof input === \"string\") {\n    return new H3Error(input);\n  }\n  if (isError(input)) {\n    return input;\n  }\n  const err = new H3Error(input.message ?? input.statusMessage, input.cause ? { cause: input.cause } : void 0);\n  if (\"stack\" in input) {\n    try {\n      Object.defineProperty(err, \"stack\", { get() {\n        return input.stack;\n      } });\n    } catch {\n      try {\n        err.stack = input.stack;\n      } catch {\n      }\n    }\n  }\n  if (input.data) {\n    err.data = input.data;\n  }\n  if (input.statusCode) {\n    err.statusCode = input.statusCode;\n  } else if (input.status) {\n    err.statusCode = input.status;\n  }\n  if (input.statusMessage) {\n    err.statusMessage = input.statusMessage;\n  } else if (input.statusText) {\n    err.statusMessage = input.statusText;\n  }\n  if (input.fatal !== void 0) {\n    err.fatal = input.fatal;\n  }\n  if (input.unhandled !== void 0) {\n    err.unhandled = input.unhandled;\n  }\n  return err;\n}\nfunction sendError(event, error, debug) {\n  if (event.res.writableEnded) {\n    return;\n  }\n  const h3Error = isError(error) ? error : createError(error);\n  const responseBody = {\n    statusCode: h3Error.statusCode,\n    statusMessage: h3Error.statusMessage,\n    stack: [],\n    data: h3Error.data\n  };\n  if (debug) {\n    responseBody.stack = (h3Error.stack || \"\").split(\"\\n\").map((l) => l.trim());\n  }\n  if (event.res.writableEnded) {\n    return;\n  }\n  const _code = parseInt(h3Error.statusCode);\n  if (_code) {\n    event.res.statusCode = _code;\n  }\n  if (h3Error.statusMessage) {\n    event.res.statusMessage = h3Error.statusMessage;\n  }\n  event.res.setHeader(\"content-type\", MIMES.json);\n  event.res.end(JSON.stringify(responseBody, null, 2));\n}\nfunction isError(input) {\n  return input?.constructor?.__h3_error__ === true;\n}\n\nfunction getQuery(event) {\n  return getQuery$1(event.req.url || \"\");\n}\nconst useQuery = getQuery;\nfunction getRouterParams(event) {\n  return event.context.params || {};\n}\nfunction getRouterParam(event, name) {\n  const params = getRouterParams(event);\n  return params[name];\n}\nfunction getMethod(event, defaultMethod = \"GET\") {\n  return (event.req.method || defaultMethod).toUpperCase();\n}\nconst useMethod = getMethod;\nfunction isMethod(event, expected, allowHead) {\n  const method = getMethod(event);\n  if (allowHead && method === \"HEAD\") {\n    return true;\n  }\n  if (typeof expected === \"string\") {\n    if (method === expected) {\n      return true;\n    }\n  } else if (expected.includes(method)) {\n    return true;\n  }\n  return false;\n}\nfunction assertMethod(event, expected, allowHead) {\n  if (!isMethod(event, expected, allowHead)) {\n    throw createError({\n      statusCode: 405,\n      statusMessage: \"HTTP method is not allowed.\"\n    });\n  }\n}\nfunction getRequestHeaders(event) {\n  const _headers = {};\n  for (const key in event.req.headers) {\n    const val = event.req.headers[key];\n    _headers[key] = Array.isArray(val) ? val.filter(Boolean).join(\", \") : val;\n  }\n  return _headers;\n}\nconst getHeaders = getRequestHeaders;\nfunction getRequestHeader(event, name) {\n  const headers = getRequestHeaders(event);\n  const value = headers[name.toLowerCase()];\n  return value;\n}\nconst getHeader = getRequestHeader;\n\nconst RawBodySymbol = Symbol.for(\"h3RawBody\");\nconst ParsedBodySymbol = Symbol.for(\"h3ParsedBody\");\nconst PayloadMethods = [\"PATCH\", \"POST\", \"PUT\", \"DELETE\"];\nfunction readRawBody(event, encoding = \"utf-8\") {\n  assertMethod(event, PayloadMethods);\n  if (RawBodySymbol in event.req) {\n    const promise2 = Promise.resolve(event.req[RawBodySymbol]);\n    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;\n  }\n  if (\"body\" in event.req) {\n    return Promise.resolve(event.req.body);\n  }\n  if (!parseInt(event.req.headers[\"content-length\"] || \"\")) {\n    return Promise.resolve(void 0);\n  }\n  const promise = event.req[RawBodySymbol] = new Promise((resolve, reject) => {\n    const bodyData = [];\n    event.req.on(\"error\", (err) => {\n      reject(err);\n    }).on(\"data\", (chunk) => {\n      bodyData.push(chunk);\n    }).on(\"end\", () => {\n      resolve(Buffer.concat(bodyData));\n    });\n  });\n  return encoding ? promise.then((buff) => buff.toString(encoding)) : promise;\n}\nconst useRawBody = readRawBody;\nasync function readBody(event) {\n  if (ParsedBodySymbol in event.req) {\n    return event.req[ParsedBodySymbol];\n  }\n  const body = await readRawBody(event);\n  if (event.req.headers[\"content-type\"] === \"application/x-www-form-urlencoded\") {\n    const parsedForm = Object.fromEntries(new URLSearchParams(body));\n    return parsedForm;\n  }\n  const json = destr(body);\n  event.req[ParsedBodySymbol] = json;\n  return json;\n}\nconst useBody = readBody;\n\nfunction handleCacheHeaders(event, opts) {\n  const cacheControls = [\"public\"].concat(opts.cacheControls || []);\n  let cacheMatched = false;\n  if (opts.maxAge !== void 0) {\n    cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);\n  }\n  if (opts.modifiedTime) {\n    const modifiedTime = new Date(opts.modifiedTime);\n    const ifModifiedSince = event.req.headers[\"if-modified-since\"];\n    event.res.setHeader(\"last-modified\", modifiedTime.toUTCString());\n    if (ifModifiedSince) {\n      if (new Date(ifModifiedSince) >= opts.modifiedTime) {\n        cacheMatched = true;\n      }\n    }\n  }\n  if (opts.etag) {\n    event.res.setHeader(\"etag\", opts.etag);\n    const ifNonMatch = event.req.headers[\"if-none-match\"];\n    if (ifNonMatch === opts.etag) {\n      cacheMatched = true;\n    }\n  }\n  event.res.setHeader(\"cache-control\", cacheControls.join(\", \"));\n  if (cacheMatched) {\n    event.res.statusCode = 304;\n    event.res.end();\n    return true;\n  }\n  return false;\n}\n\nconst MIMES = {\n  html: \"text/html\",\n  json: \"application/json\"\n};\n\nconst defer = typeof setImmediate !== \"undefined\" ? setImmediate : (fn) => fn();\nfunction send(event, data, type) {\n  if (type) {\n    defaultContentType(event, type);\n  }\n  return new Promise((resolve) => {\n    defer(() => {\n      event.res.end(data);\n      resolve(void 0);\n    });\n  });\n}\nfunction defaultContentType(event, type) {\n  if (type && !event.res.getHeader(\"content-type\")) {\n    event.res.setHeader(\"content-type\", type);\n  }\n}\nfunction sendRedirect(event, location, code = 302) {\n  event.res.statusCode = code;\n  event.res.setHeader(\"location\", location);\n  const encodedLoc = location.replace(/\"/g, \"%22\");\n  const html = `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`;\n  return send(event, html, MIMES.html);\n}\nfunction getResponseHeaders(event) {\n  return event.res.getHeaders();\n}\nfunction getResponseHeader(event, name) {\n  return event.res.getHeader(name);\n}\nfunction setResponseHeaders(event, headers) {\n  Object.entries(headers).forEach(([name, value]) => event.res.setHeader(name, value));\n}\nconst setHeaders = setResponseHeaders;\nfunction setResponseHeader(event, name, value) {\n  event.res.setHeader(name, value);\n}\nconst setHeader = setResponseHeader;\nfunction appendResponseHeaders(event, headers) {\n  Object.entries(headers).forEach(([name, value]) => appendResponseHeader(event, name, value));\n}\nconst appendHeaders = appendResponseHeaders;\nfunction appendResponseHeader(event, name, value) {\n  let current = event.res.getHeader(name);\n  if (!current) {\n    event.res.setHeader(name, value);\n    return;\n  }\n  if (!Array.isArray(current)) {\n    current = [current.toString()];\n  }\n  event.res.setHeader(name, current.concat(value));\n}\nconst appendHeader = appendResponseHeader;\nfunction isStream(data) {\n  return data && typeof data === \"object\" && typeof data.pipe === \"function\" && typeof data.on === \"function\";\n}\nfunction sendStream(event, data) {\n  return new Promise((resolve, reject) => {\n    data.pipe(event.res);\n    data.on(\"end\", () => resolve(void 0));\n    data.on(\"error\", (error) => reject(createError(error)));\n  });\n}\nconst noop = () => {\n};\nfunction writeEarlyHints(event, hints, cb = noop) {\n  if (!event.res.socket) {\n    cb();\n    return;\n  }\n  if (typeof hints === \"string\" || Array.isArray(hints)) {\n    hints = { link: hints };\n  }\n  if (hints.link) {\n    hints.link = Array.isArray(hints.link) ? hints.link : hints.link.split(\",\");\n  }\n  const headers = Object.entries(hints).map((e) => [e[0].toLowerCase(), e[1]]);\n  if (!headers.length) {\n    cb();\n    return;\n  }\n  let hint = \"HTTP/1.1 103 Early Hints\";\n  if (hints.link) {\n    hint += `\\r\nLink: ${hints.link.join(\", \")}`;\n  }\n  for (const [header, value] of headers) {\n    if (header === \"link\") {\n      continue;\n    }\n    hint += `\\r\n${header}: ${value}`;\n  }\n  event.res.socket.write(`${hint}\\r\n\\r\n`, \"utf-8\", cb);\n}\n\nfunction parseCookies(event) {\n  return parse(event.req.headers.cookie || \"\");\n}\nconst useCookies = parseCookies;\nfunction getCookie(event, name) {\n  return parseCookies(event)[name];\n}\nconst useCookie = getCookie;\nfunction setCookie(event, name, value, serializeOptions) {\n  const cookieStr = serialize(name, value, {\n    path: \"/\",\n    ...serializeOptions\n  });\n  appendHeader(event, \"Set-Cookie\", cookieStr);\n}\nfunction deleteCookie(event, name, serializeOptions) {\n  setCookie(event, name, \"\", {\n    ...serializeOptions,\n    maxAge: 0\n  });\n}\n\nasync function sendProxy(event, target, opts = {}) {\n  const _fetch = opts.fetch || globalThis.fetch;\n  if (!_fetch) {\n    throw new Error(\"fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js.\");\n  }\n  const response = await _fetch(target, {\n    headers: opts.headers,\n    ...opts.fetchOptions\n  });\n  event.res.statusCode = response.status;\n  event.res.statusMessage = response.statusText;\n  for (const [key, value] of response.headers.entries()) {\n    if (key === \"content-encoding\") {\n      continue;\n    }\n    if (key === \"content-length\") {\n      continue;\n    }\n    event.res.setHeader(key, value);\n  }\n  try {\n    if (response.body) {\n      if (opts.sendStream === false) {\n        const data = new Uint8Array(await response.arrayBuffer());\n        event.res.end(data);\n      } else {\n        for await (const chunk of response.body) {\n          event.res.write(chunk);\n        }\n        event.res.end();\n      }\n    }\n  } catch (err) {\n    event.res.end();\n    throw err;\n  }\n}\n\nclass H3Headers {\n  constructor(init) {\n    if (!init) {\n      this._headers = {};\n    } else if (Array.isArray(init)) {\n      this._headers = Object.fromEntries(init.map(([key, value]) => [key.toLowerCase(), value]));\n    } else if (init && \"append\" in init) {\n      this._headers = Object.fromEntries([...init.entries()]);\n    } else {\n      this._headers = Object.fromEntries(Object.entries(init).map(([key, value]) => [key.toLowerCase(), value]));\n    }\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  entries() {\n    throw Object.entries(this._headers)[Symbol.iterator]();\n  }\n  keys() {\n    return Object.keys(this._headers)[Symbol.iterator]();\n  }\n  values() {\n    throw Object.values(this._headers)[Symbol.iterator]();\n  }\n  append(name, value) {\n    const _name = name.toLowerCase();\n    this.set(_name, [this.get(_name), value].filter(Boolean).join(\", \"));\n  }\n  delete(name) {\n    delete this._headers[name.toLowerCase()];\n  }\n  get(name) {\n    return this._headers[name.toLowerCase()];\n  }\n  has(name) {\n    return name.toLowerCase() in this._headers;\n  }\n  set(name, value) {\n    this._headers[name.toLowerCase()] = String(value);\n  }\n  forEach(callbackfn) {\n    Object.entries(this._headers).forEach(([key, value]) => callbackfn(value, key, this));\n  }\n}\n\nclass H3Response {\n  constructor(body = null, init = {}) {\n    this.body = null;\n    this.type = \"default\";\n    this.bodyUsed = false;\n    this.headers = new H3Headers(init.headers);\n    this.status = init.status ?? 200;\n    this.statusText = init.statusText || \"\";\n    this.redirected = !!init.status && [301, 302, 307, 308].includes(init.status);\n    this._body = body;\n    this.url = \"\";\n    this.ok = this.status < 300 && this.status > 199;\n  }\n  clone() {\n    return new H3Response(this.body, {\n      headers: this.headers,\n      status: this.status,\n      statusText: this.statusText\n    });\n  }\n  arrayBuffer() {\n    return Promise.resolve(this._body);\n  }\n  blob() {\n    return Promise.resolve(this._body);\n  }\n  formData() {\n    return Promise.resolve(this._body);\n  }\n  json() {\n    return Promise.resolve(this._body);\n  }\n  text() {\n    return Promise.resolve(this._body);\n  }\n}\n\nclass H3Event {\n  constructor(req, res) {\n    this[\"__is_event__\"] = true;\n    this.context = {};\n    this.req = req;\n    this.res = res;\n  }\n  respondWith(r) {\n    Promise.resolve(r).then((_response) => {\n      if (this.res.writableEnded) {\n        return;\n      }\n      const response = _response instanceof H3Response ? _response : new H3Response(_response);\n      response.headers.forEach((value, key) => {\n        this.res.setHeader(key, value);\n      });\n      if (response.status) {\n        this.res.statusCode = response.status;\n      }\n      if (response.statusText) {\n        this.res.statusMessage = response.statusText;\n      }\n      if (response.redirected) {\n        this.res.setHeader(\"location\", response.url);\n      }\n      if (!response._body) {\n        return this.res.end();\n      }\n      if (typeof response._body === \"string\" || \"buffer\" in response._body || \"byteLength\" in response._body) {\n        return this.res.end(response._body);\n      }\n      if (!response.headers.has(\"content-type\")) {\n        response.headers.set(\"content-type\", MIMES.json);\n      }\n      this.res.end(JSON.stringify(response._body));\n    });\n  }\n}\nfunction isEvent(input) {\n  return \"__is_event__\" in input;\n}\nfunction createEvent(req, res) {\n  return new H3Event(req, res);\n}\n\nfunction defineEventHandler(handler) {\n  handler.__is_handler__ = true;\n  return handler;\n}\nconst eventHandler = defineEventHandler;\nfunction isEventHandler(input) {\n  return \"__is_handler__\" in input;\n}\nfunction toEventHandler(input, _, _route) {\n  if (!isEventHandler(input)) {\n    console.warn(\n      \"[h3] Implicit event handler conversion is deprecated. Use `eventHandler()` or `fromNodeMiddleware()` to define event handlers.\",\n      _route && _route !== \"/\" ? `\n     Route: ${_route}` : \"\",\n      `\n     Handler: ${input}`\n    );\n  }\n  return input;\n}\nfunction dynamicEventHandler(initial) {\n  let current = initial;\n  const wrapper = eventHandler((event) => {\n    if (current) {\n      return current(event);\n    }\n  });\n  wrapper.set = (handler) => {\n    current = handler;\n  };\n  return wrapper;\n}\nfunction defineLazyEventHandler(factory) {\n  let _promise;\n  let _resolved;\n  const resolveHandler = () => {\n    if (_resolved) {\n      return Promise.resolve(_resolved);\n    }\n    if (!_promise) {\n      _promise = Promise.resolve(factory()).then((r) => {\n        const handler = r.default || r;\n        if (typeof handler !== \"function\") {\n          throw new TypeError(\"Invalid lazy handler result. It should be a function:\", handler);\n        }\n        _resolved = toEventHandler(r.default || r);\n        return _resolved;\n      });\n    }\n    return _promise;\n  };\n  return eventHandler((event) => {\n    if (_resolved) {\n      return _resolved(event);\n    }\n    return resolveHandler().then((handler) => handler(event));\n  });\n}\nconst lazyEventHandler = defineLazyEventHandler;\n\nfunction createApp(options = {}) {\n  const stack = [];\n  const handler = createAppEventHandler(stack, options);\n  const app = {\n    use: (arg1, arg2, arg3) => use(app, arg1, arg2, arg3),\n    handler,\n    stack,\n    options\n  };\n  return app;\n}\nfunction use(app, arg1, arg2, arg3) {\n  if (Array.isArray(arg1)) {\n    arg1.forEach((i) => use(app, i, arg2, arg3));\n  } else if (Array.isArray(arg2)) {\n    arg2.forEach((i) => use(app, arg1, i, arg3));\n  } else if (typeof arg1 === \"string\") {\n    app.stack.push(normalizeLayer({ ...arg3, route: arg1, handler: arg2 }));\n  } else if (typeof arg1 === \"function\") {\n    app.stack.push(normalizeLayer({ ...arg2, route: \"/\", handler: arg1 }));\n  } else {\n    app.stack.push(normalizeLayer({ ...arg1 }));\n  }\n  return app;\n}\nfunction createAppEventHandler(stack, options) {\n  const spacing = options.debug ? 2 : void 0;\n  return eventHandler(async (event) => {\n    event.req.originalUrl = event.req.originalUrl || event.req.url || \"/\";\n    const reqUrl = event.req.url || \"/\";\n    for (const layer of stack) {\n      if (layer.route.length > 1) {\n        if (!reqUrl.startsWith(layer.route)) {\n          continue;\n        }\n        event.req.url = reqUrl.slice(layer.route.length) || \"/\";\n      } else {\n        event.req.url = reqUrl;\n      }\n      if (layer.match && !layer.match(event.req.url, event)) {\n        continue;\n      }\n      const val = await layer.handler(event);\n      if (event.res.writableEnded) {\n        return;\n      }\n      const type = typeof val;\n      if (type === \"string\") {\n        return send(event, val, MIMES.html);\n      } else if (isStream(val)) {\n        return sendStream(event, val);\n      } else if (val === null) {\n        event.res.statusCode = 204;\n        return send(event);\n      } else if (type === \"object\" || type === \"boolean\" || type === \"number\") {\n        if (val.buffer) {\n          return send(event, val);\n        } else if (val instanceof Error) {\n          throw createError(val);\n        } else {\n          return send(event, JSON.stringify(val, null, spacing), MIMES.json);\n        }\n      }\n    }\n    if (!event.res.writableEnded) {\n      throw createError({\n        statusCode: 404,\n        statusMessage: `Cannot find any route matching ${event.req.url || \"/\"}.`\n      });\n    }\n  });\n}\nfunction normalizeLayer(input) {\n  let handler = input.handler;\n  if (handler.handler) {\n    handler = handler.handler;\n  }\n  if (input.lazy) {\n    handler = lazyEventHandler(handler);\n  } else if (!isEventHandler(handler)) {\n    handler = toEventHandler(handler, null, input.route);\n  }\n  return {\n    route: withoutTrailingSlash(input.route),\n    match: input.match,\n    handler\n  };\n}\n\nconst defineNodeListener = (handler) => handler;\nconst defineNodeMiddleware = (middleware) => middleware;\nfunction fromNodeMiddleware(handler) {\n  if (isEventHandler(handler)) {\n    return handler;\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\"Invalid handler. It should be a function:\", handler);\n  }\n  return eventHandler((event) => {\n    return callNodeListener(handler, event.req, event.res);\n  });\n}\nfunction toNodeListener(app) {\n  const toNodeHandle = async function(req, res) {\n    const event = createEvent(req, res);\n    try {\n      await app.handler(event);\n    } catch (_error) {\n      const error = createError(_error);\n      if (!isError(_error)) {\n        error.unhandled = true;\n      }\n      if (app.options.onError) {\n        await app.options.onError(error, event);\n      } else {\n        if (error.unhandled || error.fatal) {\n          console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\n        }\n        await sendError(event, error, !!app.options.debug);\n      }\n    }\n  };\n  return toNodeHandle;\n}\nfunction promisifyNodeListener(handler) {\n  return function(req, res) {\n    return callNodeListener(handler, req, res);\n  };\n}\nfunction callNodeListener(handler, req, res) {\n  const isMiddleware = handler.length > 2;\n  return new Promise((resolve, reject) => {\n    const next = (err) => {\n      if (isMiddleware) {\n        res.off(\"close\", next);\n        res.off(\"error\", next);\n      }\n      return err ? reject(createError(err)) : resolve(void 0);\n    };\n    try {\n      const returned = handler(req, res, next);\n      if (isMiddleware && returned === void 0) {\n        res.once(\"close\", next);\n        res.once(\"error\", next);\n      } else {\n        resolve(returned);\n      }\n    } catch (err) {\n      next(err);\n    }\n  });\n}\n\nconst RouterMethods = [\"connect\", \"delete\", \"get\", \"head\", \"options\", \"post\", \"put\", \"trace\", \"patch\"];\nfunction createRouter(opts = {}) {\n  const _router = createRouter$1({});\n  const routes = {};\n  const router = {};\n  const addRoute = (path, handler, method) => {\n    let route = routes[path];\n    if (!route) {\n      routes[path] = route = { handlers: {} };\n      _router.insert(path, route);\n    }\n    if (Array.isArray(method)) {\n      method.forEach((m) => addRoute(path, handler, m));\n    } else {\n      route.handlers[method] = toEventHandler(handler, null, path);\n    }\n    return router;\n  };\n  router.use = router.add = (path, handler, method) => addRoute(path, handler, method || \"all\");\n  for (const method of RouterMethods) {\n    router[method] = (path, handle) => router.add(path, handle, method);\n  }\n  router.handler = eventHandler((event) => {\n    let path = event.req.url || \"/\";\n    const qIndex = path.indexOf(\"?\");\n    if (qIndex !== -1) {\n      path = path.substring(0, qIndex);\n    }\n    const matched = _router.lookup(path);\n    if (!matched) {\n      if (opts.preemtive) {\n        throw createError({\n          statusCode: 404,\n          name: \"Not Found\",\n          statusMessage: `Cannot find any route matching ${event.req.url || \"/\"}.`\n        });\n      } else {\n        return;\n      }\n    }\n    const method = (event.req.method || \"get\").toLowerCase();\n    const handler = matched.handlers[method] || matched.handlers.all;\n    if (!handler) {\n      throw createError({\n        statusCode: 405,\n        name: \"Method Not Allowed\",\n        statusMessage: `Method ${method} is not allowed on this route.`\n      });\n    }\n    const params = matched.params || {};\n    event.context.params = params;\n    return handler(event);\n  });\n  return router;\n}\n\nexport { H3Error, H3Event, H3Headers, H3Response, MIMES, appendHeader, appendHeaders, appendResponseHeader, appendResponseHeaders, assertMethod, callNodeListener, createApp, createAppEventHandler, createError, createEvent, createRouter, defaultContentType, defineEventHandler, defineLazyEventHandler, defineNodeListener, defineNodeMiddleware, deleteCookie, dynamicEventHandler, eventHandler, fromNodeMiddleware, getCookie, getHeader, getHeaders, getMethod, getQuery, getRequestHeader, getRequestHeaders, getResponseHeader, getResponseHeaders, getRouterParam, getRouterParams, handleCacheHeaders, isError, isEvent, isEventHandler, isMethod, isStream, lazyEventHandler, parseCookies, promisifyNodeListener, readBody, readRawBody, send, sendError, sendProxy, sendRedirect, sendStream, setCookie, setHeader, setHeaders, setResponseHeader, setResponseHeaders, toEventHandler, toNodeListener, use, useBase, useBody, useCookie, useCookies, useMethod, useQuery, useRawBody, writeEarlyHints };\n","import { createError as _createError } from \"h3\";\nimport { toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nexport const useError = () => toRef(useNuxtApp().payload, \"error\");\nexport const showError = (_err) => {\n  const err = createError(_err);\n  try {\n    const nuxtApp = useNuxtApp();\n    nuxtApp.callHook(\"app:error\", err);\n    const error = useError();\n    error.value = error.value || err;\n  } catch {\n    throw err;\n  }\n  return err;\n};\nexport const throwError = showError;\nexport const clearError = async (options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const error = useError();\n  nuxtApp.callHook(\"app:error:cleared\", options);\n  if (options.redirect) {\n    await nuxtApp.$router.replace(options.redirect);\n  }\n  error.value = null;\n};\nexport const isNuxtError = (err) => !!(err && typeof err === \"object\" && \"__nuxt_error\" in err);\nexport const createError = (err) => {\n  const _err = _createError(err);\n  _err.__nuxt_error = true;\n  return _err;\n};\n","import { isRef, toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nexport function useState(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [_key, init] = args;\n  if (!_key || typeof _key !== \"string\") {\n    throw new TypeError(\"[nuxt] [useState] key must be a string: \" + _key);\n  }\n  if (init !== void 0 && typeof init !== \"function\") {\n    throw new Error(\"[nuxt] [useState] init must be a function: \" + init);\n  }\n  const key = \"$s\" + _key;\n  const nuxt = useNuxtApp();\n  const state = toRef(nuxt.payload.state, key);\n  if (state.value === void 0 && init) {\n    const initialValue = init();\n    if (isRef(initialValue)) {\n      nuxt.payload.state[key] = initialValue;\n      return initialValue;\n    }\n    state.value = initialValue;\n  }\n  return state;\n}\n","import { getCurrentInstance, inject } from \"vue\";\nimport { sendRedirect } from \"h3\";\nimport { hasProtocol, joinURL, parseURL } from \"ufo\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.mjs\";\nimport { createError } from \"./error.mjs\";\nimport { useState } from \"./state.mjs\";\nexport const useRouter = () => {\n  return useNuxtApp()?.$router;\n};\nexport const useRoute = () => {\n  if (getCurrentInstance()) {\n    return inject(\"_route\", useNuxtApp()._route);\n  }\n  return useNuxtApp()._route;\n};\nexport const useActiveRoute = () => {\n  return useNuxtApp()._route;\n};\nexport const defineNuxtRouteMiddleware = (middleware) => middleware;\nexport const addRouteMiddleware = (name, middleware, options = {}) => {\n  const nuxtApp = useNuxtApp();\n  if (options.global || typeof name === \"function\") {\n    nuxtApp._middleware.global.push(typeof name === \"function\" ? name : middleware);\n  } else {\n    nuxtApp._middleware.named[name] = middleware;\n  }\n};\nconst isProcessingMiddleware = () => {\n  try {\n    if (useNuxtApp()._processingMiddleware) {\n      return true;\n    }\n  } catch {\n    return true;\n  }\n  return false;\n};\nexport const navigateTo = (to, options) => {\n  if (!to) {\n    to = \"/\";\n  }\n  const toPath = typeof to === \"string\" ? to : to.path || \"/\";\n  const isExternal = hasProtocol(toPath, true);\n  if (isExternal && !options?.external) {\n    throw new Error(\"Navigating to external URL is not allowed by default. Use `nagivateTo (url, { external: true })`.\");\n  }\n  if (isExternal && parseURL(toPath).protocol === \"script:\") {\n    throw new Error(\"Cannot navigate to an URL with script protocol.\");\n  }\n  if (process.client && !isExternal && isProcessingMiddleware()) {\n    return to;\n  }\n  const router = useRouter();\n  if (process.server) {\n    const nuxtApp = useNuxtApp();\n    if (nuxtApp.ssrContext && nuxtApp.ssrContext.event) {\n      const redirectLocation = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, router.resolve(to).fullPath || \"/\");\n      return nuxtApp.callHook(\"app:redirected\").then(() => sendRedirect(nuxtApp.ssrContext.event, redirectLocation, options?.redirectCode || 302));\n    }\n  }\n  if (isExternal) {\n    if (options?.replace) {\n      location.replace(toPath);\n    } else {\n      location.href = toPath;\n    }\n    return Promise.resolve();\n  }\n  return options?.replace ? router.replace(to) : router.push(to);\n};\nexport const abortNavigation = (err) => {\n  if (process.dev && !isProcessingMiddleware()) {\n    throw new Error(\"abortNavigation() is only usable inside a route middleware handler.\");\n  }\n  if (err) {\n    throw createError(err);\n  }\n  return false;\n};\nexport const setPageLayout = (layout) => {\n  if (process.server) {\n    if (process.dev && getCurrentInstance() && useState(\"_layout\").value !== layout) {\n      console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout on the server within a component as this will cause hydration errors.\");\n    }\n    useState(\"_layout\").value = layout;\n  }\n  const nuxtApp = useNuxtApp();\n  if (process.dev && nuxtApp.isHydrating && useState(\"_layout\").value !== layout) {\n    console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout during hydration as this will cause hydration errors.\");\n  }\n  const inMiddleware = isProcessingMiddleware();\n  if (inMiddleware || process.server || nuxtApp.isHydrating) {\n    const unsubscribe = useRouter().beforeResolve((to) => {\n      to.meta.layout = layout;\n      unsubscribe();\n    });\n  }\n  if (!inMiddleware) {\n    useRoute().meta.layout = layout;\n  }\n};\n","import { defineComponent, h, ref, resolveComponent, computed, onMounted, onBeforeUnmount } from \"vue\";\nimport { hasProtocol } from \"ufo\";\nimport { preloadRouteComponents } from \"../composables/preload.mjs\";\nimport { navigateTo, useRouter } from \"../composables/router.mjs\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nconst firstNonUndefined = (...args) => args.find((arg) => arg !== void 0);\nconst DEFAULT_EXTERNAL_REL_ATTRIBUTE = \"noopener noreferrer\";\nconst requestIdleCallback = process.server ? void 0 : globalThis.requestIdleCallback || ((cb) => {\n  const start = Date.now();\n  const idleDeadline = {\n    didTimeout: false,\n    timeRemaining: () => Math.max(0, 50 - (Date.now() - start))\n  };\n  return setTimeout(() => {\n    cb(idleDeadline);\n  }, 1);\n});\nconst cancelIdleCallback = process.server ? null : globalThis.cancelIdleCallback || ((id) => {\n  clearTimeout(id);\n});\nexport function defineNuxtLink(options) {\n  const componentName = options.componentName || \"NuxtLink\";\n  const checkPropConflicts = (props, main, sub) => {\n    if (process.dev && props[main] !== void 0 && props[sub] !== void 0) {\n      console.warn(`[${componentName}] \\`${main}\\` and \\`${sub}\\` cannot be used together. \\`${sub}\\` will be ignored.`);\n    }\n  };\n  return defineComponent({\n    name: componentName,\n    props: {\n      to: {\n        type: [String, Object],\n        default: void 0,\n        required: false\n      },\n      href: {\n        type: [String, Object],\n        default: void 0,\n        required: false\n      },\n      target: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      rel: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      noRel: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      prefetch: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      noPrefetch: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      activeClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      exactActiveClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      prefetchedClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      replace: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      ariaCurrentValue: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      external: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      custom: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      }\n    },\n    setup(props, { slots }) {\n      const router = useRouter();\n      const to = computed(() => {\n        checkPropConflicts(props, \"to\", \"href\");\n        return props.to || props.href || \"\";\n      });\n      const isExternal = computed(() => {\n        if (props.external) {\n          return true;\n        }\n        if (props.target && props.target !== \"_self\") {\n          return true;\n        }\n        if (typeof to.value === \"object\") {\n          return false;\n        }\n        return to.value === \"\" || hasProtocol(to.value, true);\n      });\n      const prefetched = ref(false);\n      const el = process.server ? void 0 : ref(null);\n      if (process.client) {\n        checkPropConflicts(props, \"prefetch\", \"noPrefetch\");\n        const shouldPrefetch = props.prefetch !== false && props.noPrefetch !== true && typeof to.value === \"string\" && props.target !== \"_blank\" && !isSlowConnection();\n        if (shouldPrefetch) {\n          const nuxtApp = useNuxtApp();\n          const observer = useObserver();\n          let idleId;\n          let unobserve = null;\n          onMounted(() => {\n            idleId = requestIdleCallback(() => {\n              if (el?.value?.tagName) {\n                unobserve = observer.observe(el.value, async () => {\n                  unobserve?.();\n                  unobserve = null;\n                  await Promise.all([\n                    nuxtApp.hooks.callHook(\"link:prefetch\", to.value).catch(() => {\n                    }),\n                    !isExternal.value && preloadRouteComponents(to.value, router).catch(() => {\n                    })\n                  ]);\n                  prefetched.value = true;\n                });\n              }\n            });\n          });\n          onBeforeUnmount(() => {\n            if (idleId) {\n              cancelIdleCallback(idleId);\n            }\n            unobserve?.();\n            unobserve = null;\n          });\n        }\n      }\n      return () => {\n        if (!isExternal.value) {\n          return h(\n            resolveComponent(\"RouterLink\"),\n            {\n              ref: process.server ? void 0 : (ref2) => {\n                el.value = ref2?.$el;\n              },\n              to: to.value,\n              ...prefetched.value && !props.custom ? { class: props.prefetchedClass || options.prefetchedClass } : {},\n              activeClass: props.activeClass || options.activeClass,\n              exactActiveClass: props.exactActiveClass || options.exactActiveClass,\n              replace: props.replace,\n              ariaCurrentValue: props.ariaCurrentValue,\n              custom: props.custom\n            },\n            slots.default\n          );\n        }\n        const href = typeof to.value === \"object\" ? router.resolve(to.value)?.href ?? null : to.value || null;\n        const target = props.target || null;\n        checkPropConflicts(props, \"noRel\", \"rel\");\n        const rel = props.noRel ? null : firstNonUndefined(props.rel, options.externalRelAttribute, href ? DEFAULT_EXTERNAL_REL_ATTRIBUTE : \"\") || null;\n        const navigate = () => navigateTo(href, { replace: props.replace });\n        if (props.custom) {\n          if (!slots.default) {\n            return null;\n          }\n          return slots.default({\n            href,\n            navigate,\n            route: router.resolve(href),\n            rel,\n            target,\n            isActive: false,\n            isExactActive: false\n          });\n        }\n        return h(\"a\", { ref: el, href, rel, target }, slots.default?.());\n      };\n    }\n  });\n}\nexport default defineNuxtLink({ componentName: \"NuxtLink\" });\nfunction useObserver() {\n  if (process.server) {\n    return;\n  }\n  const nuxtApp = useNuxtApp();\n  if (nuxtApp._observer) {\n    return nuxtApp._observer;\n  }\n  let observer = null;\n  const callbacks = /* @__PURE__ */ new Map();\n  const observe = (element, callback) => {\n    if (!observer) {\n      observer = new IntersectionObserver((entries) => {\n        for (const entry of entries) {\n          const callback2 = callbacks.get(entry.target);\n          const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n          if (isVisible && callback2) {\n            callback2();\n          }\n        }\n      });\n    }\n    callbacks.set(element, callback);\n    observer.observe(element);\n    return () => {\n      callbacks.delete(element);\n      observer.unobserve(element);\n      if (callbacks.size === 0) {\n        observer.disconnect();\n        observer = null;\n      }\n    };\n  };\n  const _observer = nuxtApp._observer = {\n    observe\n  };\n  return _observer;\n}\nfunction isSlowConnection() {\n  if (process.server) {\n    return;\n  }\n  const cn = navigator.connection;\n  if (cn && (cn.saveData || /2g/.test(cn.effectiveType))) {\n    return true;\n  }\n  return false;\n}\n","function isObject(val) {\n  return val !== null && typeof val === \"object\";\n}\nfunction _defu(baseObj, defaults, namespace = \".\", merger) {\n  if (!isObject(defaults)) {\n    return _defu(baseObj, {}, namespace, merger);\n  }\n  const obj = Object.assign({}, defaults);\n  for (const key in baseObj) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const val = baseObj[key];\n    if (val === null || val === void 0) {\n      continue;\n    }\n    if (merger && merger(obj, key, val, namespace)) {\n      continue;\n    }\n    if (Array.isArray(val) && Array.isArray(obj[key])) {\n      obj[key] = val.concat(obj[key]);\n    } else if (isObject(val) && isObject(obj[key])) {\n      obj[key] = _defu(val, obj[key], (namespace ? `${namespace}.` : \"\") + key.toString(), merger);\n    } else {\n      obj[key] = val;\n    }\n  }\n  return obj;\n}\nfunction createDefu(merger) {\n  return (...args) => args.reduce((p, c) => _defu(p, c, \"\", merger), {});\n}\nconst defu = createDefu();\nconst defuFn = createDefu((obj, key, currentValue, _namespace) => {\n  if (typeof obj[key] !== \"undefined\" && typeof currentValue === \"function\") {\n    obj[key] = currentValue(obj[key]);\n    return true;\n  }\n});\nconst defuArrayFn = createDefu((obj, key, currentValue, _namespace) => {\n  if (Array.isArray(obj[key]) && typeof currentValue === \"function\") {\n    obj[key] = currentValue(obj[key]);\n    return true;\n  }\n});\n\nexport { createDefu, defu as default, defu, defuArrayFn, defuFn };\n","\nimport { defuFn } from '/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/node_modules/defu/dist/defu.mjs'\n\nconst inlineConfig = {}\n\n\n\nexport default defuFn(inlineConfig)\n","import { useNuxtApp } from \"#app\";\nexport function useHead(meta) {\n  useNuxtApp()._useHead(meta);\n}\nexport function useMeta(meta) {\n  return useHead(meta);\n}\n","import { defineAsyncComponent } from 'vue'\nimport { defineNuxtPlugin } from '#app'\n\nconst components = {}\n\nexport default defineNuxtPlugin(nuxtApp => {\n  for (const name in components) {\n    nuxtApp.vueApp.component(name, components[name])\n    nuxtApp.vueApp.component('Lazy' + name, components[name])\n  }\n})\n","import { shallowRef, watchEffect, readonly, unref, ref, isVue3, watch, customRef, effectScope, provide, inject, getCurrentScope, onScopeDispose, isRef, computed, reactive, toRefs as toRefs$1, toRef, isVue2, set as set$1, getCurrentInstance, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';\n\nvar __defProp$9 = Object.defineProperty;\nvar __defProps$6 = Object.defineProperties;\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$9 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$b.call(b, prop))\n      __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$b)\n    for (var prop of __getOwnPropSymbols$b(b)) {\n      if (__propIsEnum$b.call(b, prop))\n        __defNormalProp$9(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, __spreadProps$6(__spreadValues$9({}, options), {\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  }));\n  return readonly(result);\n}\n\nvar _a;\nconst isClient = typeof window !== \"undefined\";\nconst isDef = (val) => typeof val !== \"undefined\";\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isBoolean = (val) => typeof val === \"boolean\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isNumber = (val) => typeof val === \"number\";\nconst isString = (val) => typeof val === \"string\";\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst isWindow = (val) => typeof window !== \"undefined\" && toString.call(val) === \"[object Window]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\n\nfunction resolveUnref(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    filter(() => fn.apply(this, args), { fn, thisArg: this, args });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  const filter = (invoke) => {\n    const duration = resolveUnref(ms);\n    const maxDuration = resolveUnref(options.maxWait);\n    if (timer)\n      clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return invoke();\n    }\n    if (maxDuration && !maxTimer) {\n      maxTimer = setTimeout(() => {\n        if (timer)\n          clearTimeout(timer);\n        maxTimer = null;\n        invoke();\n      }, maxDuration);\n    }\n    timer = setTimeout(() => {\n      if (maxTimer)\n        clearTimeout(maxTimer);\n      maxTimer = null;\n      invoke();\n    }, duration);\n  };\n  return filter;\n}\nfunction throttleFilter(ms, trailing = true, leading = true) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n  };\n  const filter = (invoke) => {\n    const duration = resolveUnref(ms);\n    const elapsed = Date.now() - lastExec;\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      timer = setTimeout(() => {\n        lastExec = Date.now();\n        isLeading = true;\n        clear();\n        invoke();\n      }, duration - elapsed);\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive, pause, resume, eventFilter };\n}\n\nfunction __onlyVue3(name = \"this function\") {\n  if (isVue3)\n    return;\n  throw new Error(`[VueUse] ${name} is only works on Vue 3.`);\n}\nconst directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?[0-9]+\\.?[0-9]*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\" });\n  const get = isFunction(fn) ? fn : fn.get;\n  const set = isFunction(fn) ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction createEventHook() {\n  const fns = [];\n  const off = (fn) => {\n    const index = fns.indexOf(fn);\n    if (index !== -1)\n      fns.splice(index, 1);\n  };\n  const on = (fn) => {\n    fns.push(fn);\n    return {\n      off: () => off(fn)\n    };\n  };\n  const trigger = (param) => {\n    fns.forEach((fn) => fn(param));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return () => {\n    if (!initialized) {\n      state = scope.run(stateFactory);\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nfunction createInjectionState(composable) {\n  const key = Symbol(\"InjectionState\");\n  const useProvidingState = (...args) => {\n    provide(key, composable(...args));\n  };\n  const useInjectedState = () => inject(key);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  __onlyVue3();\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$8 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$a.call(b, prop))\n      __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a)\n    for (var prop of __getOwnPropSymbols$a(b)) {\n      if (__propIsEnum$a.call(b, prop))\n        __defNormalProp$8(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = __spreadValues$8({}, obj);\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : resolveUnref;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(keys.map((key) => {\n    const value = obj[key];\n    return [\n      key,\n      typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n    ];\n  }));\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  return reactiveComputed(() => Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  return reactive(Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = defaultValue;\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = defaultValue;\n      trigger();\n    }, resolveUnref(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(debounceFilter(ms, options), fn);\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true) {\n  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(ref, {\n    get,\n    set,\n    untrackedGet,\n    silentSet,\n    peek,\n    lay\n  }, { enumerable: true });\n}\nconst controlledRef = refWithControl;\n\nfunction resolveRef(r) {\n  return typeof r === \"function\" ? computed(r) : ref(r);\n}\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction syncRef(left, right, options = {}) {\n  var _a, _b;\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options;\n  let watchLeft;\n  let watchRight;\n  const transformLTR = (_a = transform.ltr) != null ? _a : (v) => v;\n  const transformRTL = (_b = transform.rtl) != null ? _b : (v) => v;\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchLeft = watch(left, (newValue) => right.value = transformLTR(newValue), { flush, deep, immediate });\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchRight = watch(right, (newValue) => left.value = transformRTL(newValue), { flush, deep, immediate });\n  }\n  return () => {\n    watchLeft == null ? void 0 : watchLeft();\n    watchRight == null ? void 0 : watchRight();\n  };\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(source, (newValue) => targets.forEach((target) => target.value = newValue), { flush, deep, immediate });\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$7 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$9.call(b, prop))\n      __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9)\n    for (var prop of __getOwnPropSymbols$9(b)) {\n      if (__propIsEnum$9.call(b, prop))\n        __defNormalProp$7(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\nfunction toRefs(objectRef) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        if (Array.isArray(objectRef.value)) {\n          const copy = [...objectRef.value];\n          copy[key] = v;\n          objectRef.value = copy;\n        } else {\n          const newObject = __spreadProps$5(__spreadValues$7({}, objectRef.value), { [key]: v });\n          Object.setPrototypeOf(newObject, objectRef.value);\n          objectRef.value = newObject;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true) {\n  if (getCurrentInstance())\n    onBeforeMount(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn) {\n  if (getCurrentInstance())\n    onBeforeUnmount(fn);\n}\n\nfunction tryOnMounted(fn, sync = true) {\n  if (getCurrentInstance())\n    onMounted(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn) {\n  if (getCurrentInstance())\n    onUnmounted(fn);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(r, (v) => {\n        if (condition(v) !== isNot) {\n          stop == null ? void 0 : stop();\n          resolve(v);\n        }\n      }, {\n        flush,\n        deep,\n        immediate: true\n      });\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => stop == null ? void 0 : stop()));\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch([r, value], ([v1, v2]) => {\n        if (isNot !== (v1 === v2)) {\n          stop == null ? void 0 : stop();\n          resolve(v1);\n        }\n      }, {\n        flush,\n        deep,\n        immediate: true\n      });\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => {\n        stop == null ? void 0 : stop();\n        return resolveUnref(r);\n      }));\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(resolveUnref(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(resolveUnref(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction useArrayEvery(list, fn) {\n  return computed(() => resolveUnref(list).every((element, index, array) => fn(resolveUnref(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return computed(() => resolveUnref(resolveUnref(list).find((element, index, array) => fn(resolveUnref(element), index, array))));\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => resolveUnref(list).findIndex((element, index, array) => fn(resolveUnref(element), index, array)));\n}\n\nfunction useArrayJoin(list, separator) {\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).join(resolveUnref(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(resolveUnref(sum), resolveUnref(value), index);\n  return computed(() => {\n    const resolved = resolveUnref(list);\n    return args.length ? resolved.reduce(reduceCallback, resolveUnref(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return computed(() => resolveUnref(list).some((element, index, array) => fn(resolveUnref(element), index, array)));\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  const count = ref(initialValue);\n  const {\n    max = Infinity,\n    min = -Infinity\n  } = options;\n  const inc = (delta = 1) => count.value = Math.min(max, count.value + delta);\n  const dec = (delta = 1) => count.value = Math.max(min, count.value - delta);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = initialValue) => {\n    initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/;\nconst REGEX_FORMAT = /\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nconst defaultMeridiem = (hours, minutes, isLowercase, hasPeriod) => {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n};\nconst formatDate = (date, formatStr, options = {}) => {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(options.locales, { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(options.locales, { month: \"long\" }),\n    D: () => String(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(options.locales, { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(options.locales, { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(options.locales, { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => $1 || matches[match]());\n};\nconst normalizeDate = (date) => {\n  if (date === null)\n    return new Date(NaN);\n  if (date === void 0)\n    return new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n};\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(resolveUnref(date)), resolveUnref(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    if (unref(interval) <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    timer = setInterval(cb, resolveUnref(interval));\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval)) {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$6 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$8.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$8)\n    for (var prop of __getOwnPropSymbols$8(b)) {\n      if (__propIsEnum$8.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = ref(0);\n  const update = () => counter.value += 1;\n  const controls = useIntervalFn(callback ? () => {\n    update();\n    callback(counter.value);\n  } : update, interval, { immediate });\n  if (exposeControls) {\n    return __spreadValues$6({\n      counter\n    }, controls);\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(source, () => ms.value = timestamp(), options);\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, resolveUnref(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending,\n    start,\n    stop\n  };\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$7.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$7)\n    for (var prop of __getOwnPropSymbols$7(b)) {\n      if (__propIsEnum$7.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(callback != null ? callback : noop, interval, options);\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return __spreadValues$5({\n      ready\n    }, controls);\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = resolveUnref(value);\n    if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return computed(() => `${resolveUnref(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = resolveUnref(truthyValue);\n      _value.value = _value.value === truthy ? resolveUnref(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [\n    ...source instanceof Function ? source() : Array.isArray(source) ? source : unref(source)\n  ];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = new Array(oldList.length);\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __objRest$5 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchWithFilter(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$5(_a, [\n    \"eventFilter\"\n  ]);\n  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);\n}\n\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __objRest$4 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchAtMost(source, cb, options) {\n  const _a = options, {\n    count\n  } = _a, watchOptions = __objRest$4(_a, [\n    \"count\"\n  ]);\n  const current = ref(0);\n  const stop = watchWithFilter(source, (...args) => {\n    current.value += 1;\n    if (current.value >= resolveUnref(count))\n      nextTick(() => stop());\n    cb(...args);\n  }, watchOptions);\n  return { count: current, stop };\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$4.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(b)) {\n      if (__propIsEnum$4.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\nvar __objRest$3 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchDebounced(source, cb, options = {}) {\n  const _a = options, {\n    debounce = 0,\n    maxWait = void 0\n  } = _a, watchOptions = __objRest$3(_a, [\n    \"debounce\",\n    \"maxWait\"\n  ]);\n  return watchWithFilter(source, cb, __spreadProps$4(__spreadValues$4({}, watchOptions), {\n    eventFilter: debounceFilter(debounce, { maxWait })\n  }));\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nvar __objRest$2 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$3.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$3.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchIgnorable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$2(_a, [\n    \"eventFilter\"\n  ]);\n  const filteredCb = createFilterWrapper(eventFilter, cb);\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(source, (...args) => {\n      if (!ignore.value)\n        filteredCb(...args);\n    }, watchOptions);\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(watch(source, () => {\n      syncCounter.value++;\n    }, __spreadProps$3(__spreadValues$3({}, watchOptions), { flush: \"sync\" })));\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(watch(source, (...args) => {\n      const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n      ignoreCounter.value = 0;\n      syncCounter.value = 0;\n      if (ignore)\n        return;\n      filteredCb(...args);\n    }, watchOptions));\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nvar __objRest$1 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchPausable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter: filter\n  } = _a, watchOptions = __objRest$1(_a, [\n    \"eventFilter\"\n  ]);\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {\n    eventFilter\n  }));\n  return { stop, pause, resume, isActive };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchThrottled(source, cb, options = {}) {\n  const _a = options, {\n    throttle = 0,\n    trailing = true,\n    leading = true\n  } = _a, watchOptions = __objRest(_a, [\n    \"throttle\",\n    \"trailing\",\n    \"leading\"\n  ]);\n  return watchWithFilter(source, cb, __spreadProps$1(__spreadValues$1({}, watchOptions), {\n    eventFilter: throttleFilter(throttle, trailing, leading)\n  }));\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return __spreadProps(__spreadValues({}, res), {\n    trigger\n  });\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => getOneWatchSource(item));\n  return getOneWatchSource(sources);\n}\nfunction getOneWatchSource(source) {\n  return typeof source === \"function\" ? source() : unref(source);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  return watch(source, (v, ov, onInvalidate) => {\n    if (v)\n      cb(v, ov, onInvalidate);\n  }, options);\n}\n\nexport { __onlyVue3, assert, refAutoReset as autoResetRef, bypassFilter, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, hasOwn, identity, watchIgnorable as ignorableWatch, increaseWithUnit, invoke, isBoolean, isClient, isDef, isDefined, isFunction, isIOS, isNumber, isObject, isString, isWindow, makeDestructurable, noop, normalizeDate, now, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRefs, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchIgnorable, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","// src/index.ts\nimport {\n  inject,\n  nextTick,\n  onBeforeUnmount as onBeforeUnmount2,\n  watchEffect as watchEffect2\n} from \"vue\";\n\n// src/constants.ts\nvar PROVIDE_KEY = \"usehead\";\nvar HEAD_COUNT_KEY = \"head:count\";\nvar HEAD_ATTRS_KEY = \"data-head-attrs\";\nvar SELF_CLOSING_TAGS = [\"meta\", \"link\", \"base\"];\nvar BODY_TAG_ATTR_NAME = \"data-meta-body\";\n\n// src/utils.ts\nimport { resolveUnref } from \"@vueuse/shared\";\nimport { unref } from \"vue\";\n\n// src/ssr/index.ts\nvar propsToString = (props) => {\n  const handledAttributes = [];\n  for (const [key, value] of Object.entries(props)) {\n    if (value === false || value == null)\n      continue;\n    let attribute = key;\n    if (value !== true)\n      attribute += `=\"${String(value).replace(/\"/g, \"&quot;\")}\"`;\n    handledAttributes.push(attribute);\n  }\n  return handledAttributes.length > 0 ? ` ${handledAttributes.join(\" \")}` : \"\";\n};\nvar tagToString = (tag) => {\n  const attrs = propsToString(tag.props);\n  const openTag = `<${tag.tag}${attrs}>`;\n  return SELF_CLOSING_TAGS.includes(tag.tag) ? openTag : `${openTag}${tag.children || \"\"}</${tag.tag}>`;\n};\nvar resolveHeadEntries = (entries, force) => {\n  return entries.map((e) => {\n    if (e.input && (force || !e.resolved))\n      e.input = resolveUnrefHeadInput(e.input);\n    return e;\n  });\n};\nvar renderHeadToString = async (head) => {\n  var _a, _b;\n  const headHtml = [];\n  const bodyHtml = [];\n  let titleHtml = \"\";\n  const attrs = { htmlAttrs: {}, bodyAttrs: {} };\n  const resolvedEntries = resolveHeadEntries(head.headEntries);\n  for (const h in head.hooks[\"resolved:entries\"])\n    await head.hooks[\"resolved:entries\"][h](resolvedEntries);\n  const headTags = resolveHeadEntriesToTags(resolvedEntries);\n  for (const h in head.hooks[\"resolved:tags\"])\n    await head.hooks[\"resolved:tags\"][h](headTags);\n  for (const tag of headTags) {\n    if ((_a = tag.options) == null ? void 0 : _a.beforeTagRender)\n      tag.options.beforeTagRender(tag);\n    if (tag.tag === \"title\")\n      titleHtml = tagToString(tag);\n    else if (tag.tag === \"htmlAttrs\" || tag.tag === \"bodyAttrs\")\n      attrs[tag.tag] = { ...attrs[tag.tag], ...tag.props };\n    else if ((_b = tag.options) == null ? void 0 : _b.body)\n      bodyHtml.push(tagToString(tag));\n    else\n      headHtml.push(tagToString(tag));\n  }\n  headHtml.push(`<meta name=\"${HEAD_COUNT_KEY}\" content=\"${headHtml.length}\">`);\n  return {\n    get headTags() {\n      return titleHtml + headHtml.join(\"\");\n    },\n    get htmlAttrs() {\n      return propsToString({\n        ...attrs.htmlAttrs,\n        [HEAD_ATTRS_KEY]: Object.keys(attrs.htmlAttrs).join(\",\")\n      });\n    },\n    get bodyAttrs() {\n      return propsToString({\n        ...attrs.bodyAttrs,\n        [HEAD_ATTRS_KEY]: Object.keys(attrs.bodyAttrs).join(\",\")\n      });\n    },\n    get bodyTags() {\n      return bodyHtml.join(\"\");\n    }\n  };\n};\n\n// src/utils.ts\nvar sortTags = (aTag, bTag) => {\n  const tagWeight = (tag) => {\n    var _a;\n    if ((_a = tag.options) == null ? void 0 : _a.renderPriority)\n      return tag.options.renderPriority;\n    switch (tag.tag) {\n      case \"base\":\n        return -1;\n      case \"meta\":\n        if (tag.props.charset)\n          return -2;\n        if (tag.props[\"http-equiv\"] === \"content-security-policy\")\n          return 0;\n        return 10;\n      default:\n        return 10;\n    }\n  };\n  return tagWeight(aTag) - tagWeight(bTag);\n};\nvar tagDedupeKey = (tag) => {\n  const { props, tag: tagName, options } = tag;\n  if ([\"base\", \"title\", \"titleTemplate\", \"bodyAttrs\", \"htmlAttrs\"].includes(tagName))\n    return tagName;\n  if (tagName === \"link\" && props.rel === \"canonical\")\n    return \"canonical\";\n  if (props.charset)\n    return \"charset\";\n  if (options == null ? void 0 : options.key)\n    return `${tagName}:${options.key}`;\n  const name = [\"id\"];\n  if (tagName === \"meta\")\n    name.push(...[\"name\", \"property\", \"http-equiv\"]);\n  for (const n of name) {\n    if (typeof props[n] !== \"undefined\") {\n      return `${tagName}:${n}:${props[n]}`;\n    }\n  }\n  return tag.runtime.position;\n};\nfunction resolveUnrefHeadInput(ref2) {\n  const root = resolveUnref(ref2);\n  if (!ref2 || !root) {\n    return root;\n  }\n  if (Array.isArray(root)) {\n    return root.map(resolveUnrefHeadInput);\n  }\n  if (typeof root === \"object\") {\n    return Object.fromEntries(\n      Object.entries(root).map(([key, value]) => {\n        if (key === \"titleTemplate\")\n          return [key, unref(value)];\n        return [\n          key,\n          resolveUnrefHeadInput(value)\n        ];\n      })\n    );\n  }\n  return root;\n}\nvar resolveTag = (name, input, e) => {\n  var _a;\n  input = { ...input };\n  const tag = {\n    tag: name,\n    props: {},\n    runtime: {\n      entryId: e.id\n    },\n    options: {\n      ...e.options\n    }\n  };\n  [\"hid\", \"vmid\", \"key\"].forEach((key) => {\n    if (input[key]) {\n      tag.options.key = input[key];\n      delete input[key];\n    }\n  });\n  [\"children\", \"innerHTML\", \"textContent\"].forEach((key) => {\n    if (typeof input[key] !== \"undefined\") {\n      tag.children = input[key];\n      delete input[key];\n    }\n  });\n  [\"body\", \"renderPriority\"].forEach((key) => {\n    if (typeof input[key] !== \"undefined\") {\n      tag.options[key] = input[key];\n      delete input[key];\n    }\n  });\n  if ((_a = tag.options) == null ? void 0 : _a.body)\n    input[BODY_TAG_ATTR_NAME] = true;\n  tag.props = input;\n  return tag;\n};\nvar headInputToTags = (e) => {\n  return Object.entries(e.input).filter(([, v]) => typeof v !== \"undefined\").map(([key, value]) => {\n    return (Array.isArray(value) ? value : [value]).map((props) => {\n      switch (key) {\n        case \"title\":\n        case \"titleTemplate\":\n          return {\n            tag: key,\n            children: props,\n            props: {},\n            runtime: { entryId: e.id },\n            options: e.options\n          };\n        case \"base\":\n        case \"meta\":\n        case \"link\":\n        case \"style\":\n        case \"script\":\n        case \"noscript\":\n        case \"htmlAttrs\":\n        case \"bodyAttrs\":\n          return resolveTag(key, props, e);\n        default:\n          return false;\n      }\n    });\n  }).flat().filter((v) => !!v);\n};\nvar renderTitleTemplate = (template, title) => {\n  if (template == null)\n    return title || null;\n  if (typeof template === \"function\")\n    return template(title);\n  return template.replace(\"%s\", title ?? \"\");\n};\nvar resolveHeadEntriesToTags = (entries) => {\n  const deduping = {};\n  const resolvedEntries = resolveHeadEntries(entries);\n  resolvedEntries.forEach((entry, entryIndex) => {\n    const tags = headInputToTags(entry);\n    tags.forEach((tag, tagIdx) => {\n      tag.runtime = tag.runtime || {};\n      tag.runtime.position = entryIndex * 1e4 + tagIdx;\n      deduping[tagDedupeKey(tag)] = tag;\n    });\n  });\n  let resolvedTags = Object.values(deduping).sort((a, b) => a.runtime.position - b.runtime.position).sort(sortTags);\n  const titleTemplateIdx = resolvedTags.findIndex((i) => i.tag === \"titleTemplate\");\n  const titleIdx = resolvedTags.findIndex((i) => i.tag === \"title\");\n  if (titleIdx !== -1 && titleTemplateIdx !== -1) {\n    const newTitle = renderTitleTemplate(\n      resolvedTags[titleTemplateIdx].children,\n      resolvedTags[titleIdx].children\n    );\n    if (newTitle !== null) {\n      resolvedTags[titleIdx].children = newTitle || resolvedTags[titleIdx].children;\n    } else {\n      resolvedTags = resolvedTags.filter((_, i) => i !== titleIdx);\n    }\n    resolvedTags = resolvedTags.filter((_, i) => i !== titleTemplateIdx);\n  } else if (titleTemplateIdx !== -1) {\n    const newTitle = renderTitleTemplate(\n      resolvedTags[titleTemplateIdx].children\n    );\n    if (newTitle !== null) {\n      resolvedTags[titleTemplateIdx].children = newTitle;\n      resolvedTags[titleTemplateIdx].tag = \"title\";\n    } else {\n      resolvedTags = resolvedTags.filter((_, i) => i !== titleTemplateIdx);\n    }\n  }\n  return resolvedTags;\n};\n\n// src/dom/utils.ts\nfunction isEqualNode(oldTag, newTag) {\n  if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {\n    const nonce = newTag.getAttribute(\"nonce\");\n    if (nonce && !oldTag.getAttribute(\"nonce\")) {\n      const cloneTag = newTag.cloneNode(true);\n      cloneTag.setAttribute(\"nonce\", \"\");\n      cloneTag.nonce = nonce;\n      return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);\n    }\n  }\n  return oldTag.isEqualNode(newTag);\n}\nvar setAttrs = (el, attrs) => {\n  const existingAttrs = el.getAttribute(HEAD_ATTRS_KEY);\n  if (existingAttrs) {\n    for (const key of existingAttrs.split(\",\")) {\n      if (!(key in attrs))\n        el.removeAttribute(key);\n    }\n  }\n  const keys = [];\n  for (const key in attrs) {\n    const value = attrs[key];\n    if (value == null)\n      continue;\n    if (value === false)\n      el.removeAttribute(key);\n    else\n      el.setAttribute(key, value);\n    keys.push(key);\n  }\n  if (keys.length)\n    el.setAttribute(HEAD_ATTRS_KEY, keys.join(\",\"));\n  else\n    el.removeAttribute(HEAD_ATTRS_KEY);\n};\n\n// src/dom/create-element.ts\nvar createElement = (tag, document) => {\n  var _a;\n  const $el = document.createElement(tag.tag);\n  Object.entries(tag.props).forEach(([k, v]) => {\n    if (v !== false) {\n      $el.setAttribute(k, v === true ? \"\" : String(v));\n    }\n  });\n  if (tag.children) {\n    if ((_a = tag.options) == null ? void 0 : _a.safe) {\n      if (tag.tag !== \"script\")\n        $el.textContent = tag.children;\n    } else {\n      $el.innerHTML = tag.children;\n    }\n  }\n  return $el;\n};\n\n// src/dom/update-elements.ts\nvar updateElements = (document = window.document, type, tags) => {\n  var _a, _b;\n  const head = document.head;\n  const body = document.body;\n  let headCountEl = head.querySelector(`meta[name=\"${HEAD_COUNT_KEY}\"]`);\n  const bodyMetaElements = body.querySelectorAll(`[${BODY_TAG_ATTR_NAME}]`);\n  const headCount = headCountEl ? Number(headCountEl.getAttribute(\"content\")) : 0;\n  const oldHeadElements = [];\n  const oldBodyElements = [];\n  if (bodyMetaElements) {\n    for (let i = 0; i < bodyMetaElements.length; i++) {\n      if (bodyMetaElements[i] && ((_a = bodyMetaElements[i].tagName) == null ? void 0 : _a.toLowerCase()) === type)\n        oldBodyElements.push(bodyMetaElements[i]);\n    }\n  }\n  if (headCountEl) {\n    for (let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = (j == null ? void 0 : j.previousElementSibling) || null) {\n      if (((_b = j == null ? void 0 : j.tagName) == null ? void 0 : _b.toLowerCase()) === type)\n        oldHeadElements.push(j);\n    }\n  } else {\n    headCountEl = document.createElement(\"meta\");\n    headCountEl.setAttribute(\"name\", HEAD_COUNT_KEY);\n    headCountEl.setAttribute(\"content\", \"0\");\n    head.append(headCountEl);\n  }\n  let newElements = tags.map((tag) => {\n    var _a2;\n    return {\n      element: createElement(tag, document),\n      body: ((_a2 = tag.options) == null ? void 0 : _a2.body) ?? false\n    };\n  });\n  newElements = newElements.filter((newEl) => {\n    for (let i = 0; i < oldHeadElements.length; i++) {\n      const oldEl = oldHeadElements[i];\n      if (isEqualNode(oldEl, newEl.element)) {\n        oldHeadElements.splice(i, 1);\n        return false;\n      }\n    }\n    for (let i = 0; i < oldBodyElements.length; i++) {\n      const oldEl = oldBodyElements[i];\n      if (isEqualNode(oldEl, newEl.element)) {\n        oldBodyElements.splice(i, 1);\n        return false;\n      }\n    }\n    return true;\n  });\n  oldBodyElements.forEach((t) => {\n    var _a2;\n    return (_a2 = t.parentNode) == null ? void 0 : _a2.removeChild(t);\n  });\n  oldHeadElements.forEach((t) => {\n    var _a2;\n    return (_a2 = t.parentNode) == null ? void 0 : _a2.removeChild(t);\n  });\n  newElements.forEach((t) => {\n    if (t.body)\n      body.insertAdjacentElement(\"beforeend\", t.element);\n    else\n      head.insertBefore(t.element, headCountEl);\n  });\n  headCountEl.setAttribute(\n    \"content\",\n    `${headCount - oldHeadElements.length + newElements.filter((t) => !t.body).length}`\n  );\n};\n\n// src/dom/update-dom.ts\nvar updateDOM = async (head, previousTags, document) => {\n  var _a, _b;\n  const tags = {};\n  if (!document)\n    document = window.document;\n  for (const k in head.hooks[\"before:dom\"]) {\n    if (await head.hooks[\"before:dom\"][k]() === false)\n      return;\n  }\n  const resolvedEntries = resolveHeadEntries(head.headEntries);\n  for (const h in head.hooks[\"resolved:entries\"])\n    await head.hooks[\"resolved:entries\"][h](resolvedEntries);\n  const headTags = resolveHeadEntriesToTags(resolvedEntries);\n  for (const h in head.hooks[\"resolved:tags\"])\n    await head.hooks[\"resolved:tags\"][h](headTags);\n  for (const tag of headTags) {\n    switch (tag.tag) {\n      case \"title\":\n        if (typeof tag.children !== \"undefined\")\n          document.title = tag.children;\n        break;\n      case \"base\":\n      case \"meta\":\n      case \"link\":\n      case \"style\":\n      case \"script\":\n      case \"noscript\":\n        tags[tag.tag] = tags[tag.tag] || [];\n        tags[tag.tag].push(tag);\n        break;\n    }\n  }\n  setAttrs(document.documentElement, ((_a = headTags.find((t) => t.tag === \"htmlAttrs\")) == null ? void 0 : _a.props) || {});\n  setAttrs(document.body, ((_b = headTags.find((t) => t.tag === \"bodyAttrs\")) == null ? void 0 : _b.props) || {});\n  const tagKeys = /* @__PURE__ */ new Set([...Object.keys(tags), ...previousTags]);\n  for (const tag of tagKeys)\n    updateElements(document, tag, tags[tag] || []);\n  previousTags.clear();\n  Object.keys(tags).forEach((i) => previousTags.add(i));\n};\n\n// src/encoding/index.ts\nvar escapeHtml = (s) => s.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#39;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\nvar escapeJS = (s) => s.replace(/[\"'\\\\\\n\\r\\u2028\\u2029]/g, (character) => {\n  switch (character) {\n    case '\"':\n    case \"'\":\n    case \"\\\\\":\n      return `\\\\${character}`;\n    case \"\\n\":\n      return \"\\\\n\";\n    case \"\\r\":\n      return \"\\\\r\";\n    case \"\\u2028\":\n      return \"\\\\u2028\";\n    case \"\\u2029\":\n      return \"\\\\u2029\";\n  }\n  return character;\n});\nvar sanitiseAttrName = (str) => str.replace(/[\\s\"'><\\/=]/g, \"\").replace(/[^a-zA-Z0-9_-]/g, \"\");\nvar sanitiseAttrValue = (str) => escapeJS(\n  str.replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\")\n);\n\n// src/vue2-plugin.ts\nvar HeadVuePlugin = function(_Vue) {\n  _Vue.mixin({\n    beforeCreate() {\n      const options = this.$options;\n      if (options.head) {\n        const origProvide = options.provide;\n        options.provide = function() {\n          let origProvideResult;\n          if (typeof origProvide === \"function\")\n            origProvideResult = origProvide.call(this);\n          else\n            origProvideResult = origProvide || {};\n          return {\n            ...origProvideResult,\n            [PROVIDE_KEY]: options.head\n          };\n        };\n        if (!this.$head)\n          this.$head = options.head;\n      } else if (!this.$head && options.parent && options.parent.$head) {\n        this.$head = options.parent.$head;\n      }\n    }\n  });\n};\n\n// src/components.ts\nimport { defineComponent, onBeforeUnmount, ref, version, watchEffect } from \"vue\";\nvar isVue2 = version.startsWith(\"2.\");\nvar addVNodeToHeadObj = (node, obj) => {\n  const nodeType = isVue2 ? node.tag : node.type;\n  const type = nodeType === \"html\" ? \"htmlAttrs\" : nodeType === \"body\" ? \"bodyAttrs\" : nodeType;\n  if (typeof type !== \"string\" || !(type in obj))\n    return;\n  const nodeData = isVue2 ? node.data : node;\n  const props = (isVue2 ? nodeData.attrs : node.props) || {};\n  if (isVue2) {\n    if (nodeData.staticClass)\n      props.class = nodeData.staticClass;\n    if (nodeData.staticStyle)\n      props.style = Object.entries(nodeData.staticStyle).map(([key, value]) => `${key}:${value}`).join(\";\");\n  }\n  if (node.children) {\n    const childrenAttr = isVue2 ? \"text\" : \"children\";\n    props.children = Array.isArray(node.children) ? node.children[0][childrenAttr] : node[childrenAttr];\n  }\n  if (Array.isArray(obj[type]))\n    obj[type].push(props);\n  else if (type === \"title\")\n    obj.title = props.children;\n  else\n    obj[type] = props;\n};\nvar vnodesToHeadObj = (nodes) => {\n  const obj = {\n    title: void 0,\n    htmlAttrs: void 0,\n    bodyAttrs: void 0,\n    base: void 0,\n    meta: [],\n    link: [],\n    style: [],\n    script: [],\n    noscript: []\n  };\n  for (const node of nodes) {\n    if (typeof node.type === \"symbol\" && Array.isArray(node.children)) {\n      for (const childNode of node.children)\n        addVNodeToHeadObj(childNode, obj);\n    } else {\n      addVNodeToHeadObj(node, obj);\n    }\n  }\n  return obj;\n};\nvar Head = /* @__PURE__ */ defineComponent({\n  name: \"Head\",\n  setup(_, { slots }) {\n    const head = injectHead();\n    const obj = ref({});\n    if (IS_BROWSER) {\n      const cleanUp = head.addReactiveEntry(obj);\n      onBeforeUnmount(() => {\n        cleanUp();\n      });\n    } else {\n      head.addEntry(obj);\n    }\n    return () => {\n      watchEffect(() => {\n        if (!slots.default)\n          return;\n        obj.value = vnodesToHeadObj(slots.default());\n      });\n      return null;\n    };\n  }\n});\n\n// src/index.ts\nvar IS_BROWSER = typeof window !== \"undefined\";\nvar injectHead = () => {\n  const head = inject(PROVIDE_KEY);\n  if (!head)\n    throw new Error(\"You may forget to apply app.use(head)\");\n  return head;\n};\nvar createHead = (initHeadObject) => {\n  let entries = [];\n  let entryId = 0;\n  const previousTags = /* @__PURE__ */ new Set();\n  let domUpdateTick = null;\n  const head = {\n    install(app) {\n      if (app.config.globalProperties)\n        app.config.globalProperties.$head = head;\n      app.provide(PROVIDE_KEY, head);\n    },\n    hooks: {\n      \"before:dom\": [],\n      \"resolved:tags\": [],\n      \"resolved:entries\": []\n    },\n    get headEntries() {\n      return entries;\n    },\n    get headTags() {\n      const resolvedEntries = resolveHeadEntries(head.headEntries);\n      return resolveHeadEntriesToTags(resolvedEntries);\n    },\n    addHeadObjs(input, options) {\n      return head.addEntry(input, options);\n    },\n    addEntry(input, options = {}) {\n      let resolved = false;\n      if (options == null ? void 0 : options.resolved) {\n        resolved = true;\n        delete options.resolved;\n      }\n      const entry = {\n        id: entryId++,\n        options,\n        resolved,\n        input\n      };\n      entries.push(entry);\n      return {\n        remove() {\n          entries = entries.filter((_objs) => _objs.id !== entry.id);\n        },\n        update(updatedInput) {\n          entries = entries.map((e) => {\n            if (e.id === entry.id)\n              e.input = updatedInput;\n            return e;\n          });\n        }\n      };\n    },\n    async updateDOM(document, force) {\n      const doDomUpdate = () => {\n        domUpdateTick = null;\n        return updateDOM(head, previousTags, document);\n      };\n      if (force)\n        return doDomUpdate();\n      return domUpdateTick = domUpdateTick || new Promise((resolve) => nextTick(() => resolve(doDomUpdate())));\n    },\n    addReactiveEntry(input, options = {}) {\n      let entrySideEffect = null;\n      const cleanUpWatch = watchEffect2(() => {\n        const resolvedInput = resolveUnrefHeadInput(input);\n        if (entrySideEffect === null) {\n          entrySideEffect = head.addEntry(\n            resolvedInput,\n            { ...options, resolved: true }\n          );\n        } else {\n          entrySideEffect.update(resolvedInput);\n        }\n        if (IS_BROWSER)\n          head.updateDOM();\n      });\n      return () => {\n        cleanUpWatch();\n        if (entrySideEffect)\n          entrySideEffect.remove();\n      };\n    }\n  };\n  if (initHeadObject)\n    head.addEntry(initHeadObject);\n  return head;\n};\nvar _useHead = (headObj, options = {}) => {\n  const head = injectHead();\n  if (!IS_BROWSER) {\n    head.addEntry(headObj, options);\n  } else {\n    const cleanUp = head.addReactiveEntry(headObj, options);\n    onBeforeUnmount2(() => {\n      cleanUp();\n      head.updateDOM();\n    });\n  }\n};\nvar useHead = (headObj) => {\n  _useHead(headObj);\n};\nvar useHeadSafe = (headObj) => {\n  _useHead(\n    headObj,\n    {\n      beforeTagRender: (tag) => {\n        for (const p in tag.props) {\n          const value = tag.props[p];\n          const key = sanitiseAttrName(p);\n          delete tag.props[p];\n          if (!p.startsWith(\"on\") && p !== \"innerHTML\") {\n            if (p === \"href\" || p === \"src\")\n              tag.props[key] = encodeURI(value);\n            tag.props[key] = sanitiseAttrValue(value);\n          }\n        }\n        if (tag.children) {\n          if (tag.tag === \"script\")\n            delete tag.children;\n          else\n            tag.children = escapeJS(escapeHtml(tag.children));\n        }\n      }\n    }\n  );\n};\nexport {\n  Head,\n  HeadVuePlugin,\n  IS_BROWSER,\n  createElement,\n  createHead,\n  headInputToTags,\n  injectHead,\n  isEqualNode,\n  propsToString,\n  renderHeadToString,\n  resolveHeadEntries,\n  resolveHeadEntriesToTags,\n  resolveUnrefHeadInput,\n  setAttrs,\n  sortTags,\n  tagDedupeKey,\n  tagToString,\n  updateElements,\n  useHead,\n  useHeadSafe\n};\n","export const appBaseURL = \"/surveyapp\"\n\nexport const appHead = {\"meta\":[{\"charset\":\"UTF-8\"},{\"name\":\"author\",\"content\":\"Philip Swiezak\"},{\"name\":\"keywords\",\"content\":\"HTML, CSS, TypeScript, Go, Vue\"},{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],\"link\":[{\"rel\":\"icon\",\"type\":\"image/x-icon\",\"href\":\"/surveyapp/favicon.ico\"}],\"style\":[],\"script\":[],\"noscript\":[],\"title\":\"SurveyApp\",\"titleTemplate\":\"%s - Awesome Voting\"}\n\nexport const appBuildAssetsDir = \"/_nuxt/\"\n\nexport const appCdnURL = \"\"\n\nexport const appLayoutTransition = false\n\nexport const appPageTransition = false\n\nexport const appKeepalive = false","import { createHead, renderHeadToString } from \"@vueuse/head\";\nimport { onBeforeUnmount, getCurrentInstance } from \"vue\";\nimport { defineNuxtPlugin, useRouter } from \"#app\";\nimport { appHead } from \"#build/nuxt.config.mjs\";\nexport default defineNuxtPlugin((nuxtApp) => {\n  const head = createHead();\n  head.addEntry(appHead, { resolved: true });\n  nuxtApp.vueApp.use(head);\n  if (process.client) {\n    let pauseDOMUpdates = true;\n    head.hooks[\"before:dom\"].push(() => !pauseDOMUpdates);\n    nuxtApp.hooks.hookOnce(\"app:mounted\", () => {\n      pauseDOMUpdates = false;\n      head.updateDOM();\n      useRouter().beforeEach(() => {\n        pauseDOMUpdates = true;\n      });\n      useRouter().afterEach(() => {\n        if (pauseDOMUpdates) {\n          pauseDOMUpdates = false;\n          head.updateDOM();\n        }\n      });\n    });\n  }\n  nuxtApp._useHead = (_meta, options) => {\n    if (process.server) {\n      head.addEntry(_meta, options);\n      return;\n    }\n    const cleanUp = head.addReactiveEntry(_meta, options);\n    const vm = getCurrentInstance();\n    if (!vm) {\n      return;\n    }\n    onBeforeUnmount(() => {\n      cleanUp();\n      head.updateDOM();\n    });\n  };\n  if (process.server) {\n    nuxtApp.ssrContext.renderMeta = async () => {\n      const meta = await renderHeadToString(head);\n      return {\n        ...meta,\n        bodyScripts: meta.bodyTags\n      };\n    };\n  }\n});\n","import { getCurrentInstance } from \"vue\";\nimport { useHead } from \"./composables.mjs\";\nimport { defineNuxtPlugin, useNuxtApp } from \"#app\";\nconst metaMixin = {\n  created() {\n    const instance = getCurrentInstance();\n    if (!instance) {\n      return;\n    }\n    const options = instance.type;\n    if (!options || !(\"head\" in options)) {\n      return;\n    }\n    const nuxtApp = useNuxtApp();\n    const source = typeof options.head === \"function\" ? () => options.head(nuxtApp) : options.head;\n    useHead(source);\n  }\n};\nexport default defineNuxtPlugin((nuxtApp) => {\n  nuxtApp.vueApp.mixin(metaMixin);\n});\n","import { default as _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47index_46vueMeta } from \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/index.vue?macro=true\";\nimport { default as _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47login_46vueMeta } from \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/login.vue?macro=true\";\nimport { default as _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47logout_46vueMeta } from \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/logout.vue?macro=true\";\nimport { default as _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47register_46vueMeta } from \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/register.vue?macro=true\";\nimport { default as _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47unauthorized_46vueMeta } from \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/unauthorized.vue?macro=true\";\nexport default [\n  {\n    name: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47index_46vueMeta?.name ?? \"index\",\n    path: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47index_46vueMeta?.path ?? \"/\",\n    file: \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/index.vue\",\n    children: [],\n    meta: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47index_46vueMeta,\n    alias: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47index_46vueMeta?.alias || [],\n    redirect: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47index_46vueMeta?.redirect || undefined,\n    component: () => import(\"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47login_46vueMeta?.name ?? \"login\",\n    path: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47login_46vueMeta?.path ?? \"/login\",\n    file: \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/login.vue\",\n    children: [],\n    meta: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47login_46vueMeta,\n    alias: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47login_46vueMeta?.alias || [],\n    redirect: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47login_46vueMeta?.redirect || undefined,\n    component: () => import(\"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/login.vue\").then(m => m.default || m)\n  },\n  {\n    name: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47logout_46vueMeta?.name ?? \"logout\",\n    path: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47logout_46vueMeta?.path ?? \"/logout\",\n    file: \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/logout.vue\",\n    children: [],\n    meta: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47logout_46vueMeta,\n    alias: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47logout_46vueMeta?.alias || [],\n    redirect: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47logout_46vueMeta?.redirect || undefined,\n    component: () => import(\"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/logout.vue\").then(m => m.default || m)\n  },\n  {\n    name: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47register_46vueMeta?.name ?? \"register\",\n    path: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47register_46vueMeta?.path ?? \"/register\",\n    file: \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/register.vue\",\n    children: [],\n    meta: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47register_46vueMeta,\n    alias: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47register_46vueMeta?.alias || [],\n    redirect: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47register_46vueMeta?.redirect || undefined,\n    component: () => import(\"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/register.vue\").then(m => m.default || m)\n  },\n  {\n    name: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47unauthorized_46vueMeta?.name ?? \"unauthorized\",\n    path: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47unauthorized_46vueMeta?.path ?? \"/unauthorized\",\n    file: \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/unauthorized.vue\",\n    children: [],\n    meta: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47unauthorized_46vueMeta,\n    alias: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47unauthorized_46vueMeta?.alias || [],\n    redirect: _47Users_47philip_47Documents_47Projects_47SurveyApp_47client_45nuxt3_47pages_47unauthorized_46vueMeta?.redirect || undefined,\n    component: () => import(\"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/pages/unauthorized.vue\").then(m => m.default || m)\n  }\n]","import { nextTick } from \"vue\";\nimport { useNuxtApp } from \"#app\";\nexport default {\n  scrollBehavior(to, from, savedPosition) {\n    const nuxtApp = useNuxtApp();\n    let position = savedPosition || void 0;\n    if (!position && from && to && to.meta.scrollToTop !== false && _isDifferentRoute(from, to)) {\n      position = { left: 0, top: 0 };\n    }\n    if (to.path === from.path) {\n      if (from.hash && !to.hash) {\n        return { left: 0, top: 0 };\n      }\n      if (to.hash) {\n        return { el: to.hash, top: _getHashElementScrollMarginTop(to.hash) };\n      }\n    }\n    const hasTransition = to.meta.pageTransition !== false && from.meta.pageTransition !== false;\n    const hookToWait = hasTransition ? \"page:transition:finish\" : \"page:finish\";\n    return new Promise((resolve) => {\n      nuxtApp.hooks.hookOnce(hookToWait, async () => {\n        await nextTick();\n        if (to.hash) {\n          position = { el: to.hash, top: _getHashElementScrollMarginTop(to.hash) };\n        }\n        resolve(position);\n      });\n    });\n  }\n};\nfunction _getHashElementScrollMarginTop(selector) {\n  const elem = document.querySelector(selector);\n  if (elem) {\n    return parseFloat(getComputedStyle(elem).scrollMarginTop);\n  }\n  return 0;\n}\nfunction _isDifferentRoute(a, b) {\n  const samePageComponent = a.matched[0] === b.matched[0];\n  if (!samePageComponent) {\n    return true;\n  }\n  if (samePageComponent && JSON.stringify(a.params) !== JSON.stringify(b.params)) {\n    return true;\n  }\n  return false;\n}\n","import routerOptions0 from \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/node_modules/nuxt/dist/pages/runtime/router.options\";\nconst configRouterOptions = {}\nexport default {\n...configRouterOptions,\n...routerOptions0,\n}","import { createError, defineNuxtRouteMiddleware } from \"#app\";\nexport default defineNuxtRouteMiddleware(async (to) => {\n  if (!to.meta?.validate) {\n    return;\n  }\n  const result = await Promise.resolve(to.meta.validate(to));\n  if (typeof result === \"boolean\") {\n    return result;\n  }\n  return createError(result);\n});\n","import validate from \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/node_modules/nuxt/dist/pages/runtime/validate.mjs\";\nexport const globalMiddleware = [\n  validate\n]\nexport const namedMiddleware = {}","import { computed, reactive, shallowRef } from \"vue\";\nimport {\n  createRouter,\n  createWebHistory,\n  createMemoryHistory,\n  createWebHashHistory\n} from \"vue-router\";\nimport { createError } from \"h3\";\nimport { withoutBase, isEqual } from \"ufo\";\nimport { callWithNuxt, defineNuxtPlugin, useRuntimeConfig, showError, clearError, navigateTo, useError, useState } from \"#app\";\nimport _routes from \"#build/routes\";\nimport routerOptions from \"#build/router.options\";\nimport { globalMiddleware, namedMiddleware } from \"#build/middleware\";\nfunction createCurrentLocation(base, location) {\n  const { pathname, search, hash } = location;\n  const hashPos = base.indexOf(\"#\");\n  if (hashPos > -1) {\n    const slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    if (pathFromHash[0] !== \"/\") {\n      pathFromHash = \"/\" + pathFromHash;\n    }\n    return withoutBase(pathFromHash, \"\");\n  }\n  const path = withoutBase(pathname, base);\n  return path + search + hash;\n}\nexport default defineNuxtPlugin(async (nuxtApp) => {\n  let routerBase = useRuntimeConfig().app.baseURL;\n  if (routerOptions.hashMode && !routerBase.includes(\"#\")) {\n    routerBase += \"#\";\n  }\n  const history = routerOptions.history?.(routerBase) ?? (process.client ? routerOptions.hashMode ? createWebHashHistory(routerBase) : createWebHistory(routerBase) : createMemoryHistory(routerBase));\n  const routes = routerOptions.routes?.(_routes) ?? _routes;\n  const initialURL = process.server ? nuxtApp.ssrContext.url : createCurrentLocation(routerBase, window.location);\n  const router = createRouter({\n    ...routerOptions,\n    history,\n    routes\n  });\n  nuxtApp.vueApp.use(router);\n  const previousRoute = shallowRef(router.currentRoute.value);\n  router.afterEach((_to, from) => {\n    previousRoute.value = from;\n  });\n  Object.defineProperty(nuxtApp.vueApp.config.globalProperties, \"previousRoute\", {\n    get: () => previousRoute.value\n  });\n  const _route = shallowRef(router.resolve(initialURL));\n  const syncCurrentRoute = () => {\n    _route.value = router.currentRoute.value;\n  };\n  nuxtApp.hook(\"page:finish\", syncCurrentRoute);\n  router.afterEach((to, from) => {\n    if (to.matched[0]?.components?.default === from.matched[0]?.components?.default) {\n      syncCurrentRoute();\n    }\n  });\n  const route = {};\n  for (const key in _route.value) {\n    route[key] = computed(() => _route.value[key]);\n  }\n  nuxtApp._route = reactive(route);\n  nuxtApp._middleware = nuxtApp._middleware || {\n    global: [],\n    named: {}\n  };\n  const error = useError();\n  try {\n    if (process.server) {\n      await router.push(initialURL);\n    }\n    await router.isReady();\n  } catch (error2) {\n    callWithNuxt(nuxtApp, showError, [error2]);\n  }\n  const initialLayout = useState(\"_layout\");\n  router.beforeEach(async (to, from) => {\n    to.meta = reactive(to.meta);\n    if (nuxtApp.isHydrating) {\n      to.meta.layout = initialLayout.value ?? to.meta.layout;\n    }\n    nuxtApp._processingMiddleware = true;\n    const middlewareEntries = /* @__PURE__ */ new Set([...globalMiddleware, ...nuxtApp._middleware.global]);\n    for (const component of to.matched) {\n      const componentMiddleware = component.meta.middleware;\n      if (!componentMiddleware) {\n        continue;\n      }\n      if (Array.isArray(componentMiddleware)) {\n        for (const entry of componentMiddleware) {\n          middlewareEntries.add(entry);\n        }\n      } else {\n        middlewareEntries.add(componentMiddleware);\n      }\n    }\n    for (const entry of middlewareEntries) {\n      const middleware = typeof entry === \"string\" ? nuxtApp._middleware.named[entry] || await namedMiddleware[entry]?.().then((r) => r.default || r) : entry;\n      if (!middleware) {\n        if (process.dev) {\n          throw new Error(`Unknown route middleware: '${entry}'. Valid middleware: ${Object.keys(namedMiddleware).map((mw) => `'${mw}'`).join(\", \")}.`);\n        }\n        throw new Error(`Unknown route middleware: '${entry}'.`);\n      }\n      const result = await callWithNuxt(nuxtApp, middleware, [to, from]);\n      if (process.server || !nuxtApp.payload.serverRendered && nuxtApp.isHydrating) {\n        if (result === false || result instanceof Error) {\n          const error2 = result || createError({\n            statusCode: 404,\n            statusMessage: `Page Not Found: ${initialURL}`\n          });\n          return callWithNuxt(nuxtApp, showError, [error2]);\n        }\n      }\n      if (result || result === false) {\n        return result;\n      }\n    }\n  });\n  router.afterEach(async (to) => {\n    delete nuxtApp._processingMiddleware;\n    if (process.client && !nuxtApp.isHydrating && error.value) {\n      await callWithNuxt(nuxtApp, clearError);\n    }\n    if (to.matched.length === 0) {\n      callWithNuxt(nuxtApp, showError, [createError({\n        statusCode: 404,\n        fatal: false,\n        statusMessage: `Page not found: ${to.fullPath}`\n      })]);\n    } else if (process.server && to.matched[0].name === \"404\" && nuxtApp.ssrContext) {\n      nuxtApp.ssrContext.event.res.statusCode = 404;\n    } else if (process.server) {\n      const currentURL = to.fullPath || \"/\";\n      if (!isEqual(currentURL, initialURL)) {\n        await callWithNuxt(nuxtApp, navigateTo, [currentURL]);\n      }\n    }\n  });\n  nuxtApp.hooks.hookOnce(\"app:created\", async () => {\n    try {\n      await router.replace({\n        ...router.resolve(initialURL),\n        name: void 0,\n        force: true\n      });\n    } catch (error2) {\n      callWithNuxt(nuxtApp, showError, [error2]);\n    }\n  });\n  return { provide: { router } };\n});\n","import _nuxt_components_plugin_mjs_KR1HBZs4kY from \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/.nuxt/components.plugin.mjs\";\nimport node_modules_nuxt_dist_head_runtime_lib_vueuse_head_plugin_mjs_D7WGfuP1A0 from \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/node_modules/nuxt/dist/head/runtime/lib/vueuse-head.plugin.mjs\";\nimport node_modules_nuxt_dist_head_runtime_mixin_plugin_mjs_prWV5EzJWI from \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/node_modules/nuxt/dist/head/runtime/mixin-plugin.mjs\";\nimport node_modules_nuxt_dist_pages_runtime_router_mjs_qNv5Ky2ZmB from \"/Users/philip/Documents/Projects/SurveyApp/client-nuxt3/node_modules/nuxt/dist/pages/runtime/router.mjs\";\nexport default [\n  _nuxt_components_plugin_mjs_KR1HBZs4kY,\n  node_modules_nuxt_dist_head_runtime_lib_vueuse_head_plugin_mjs_D7WGfuP1A0,\n  node_modules_nuxt_dist_head_runtime_mixin_plugin_mjs_prWV5EzJWI,\n  node_modules_nuxt_dist_pages_runtime_router_mjs_qNv5Ky2ZmB\n]","import { KeepAlive, h } from \"vue\";\nconst interpolatePath = (route, match) => {\n  return match.path.replace(/(:\\w+)\\([^)]+\\)/g, \"$1\").replace(/(:\\w+)[?+*]/g, \"$1\").replace(/:\\w+/g, (r) => route.params[r.slice(1)]?.toString() || \"\");\n};\nexport const generateRouteKey = (override, routeProps) => {\n  const matchedRoute = routeProps.route.matched.find((m) => m.components?.default === routeProps.Component.type);\n  const source = override ?? matchedRoute?.meta.key ?? (matchedRoute && interpolatePath(routeProps.route, matchedRoute));\n  return typeof source === \"function\" ? source(routeProps.route) : source;\n};\nexport const wrapInKeepAlive = (props, children) => {\n  return { default: () => process.client && props ? h(KeepAlive, props === true ? {} : props, children) : children };\n};\n","import { defineComponent, h } from \"vue\";\nconst Fragment = defineComponent({\n  setup(_props, { slots }) {\n    return () => slots.default?.();\n  }\n});\nexport const _wrapIf = (component, props, slots) => {\n  return { default: () => props ? h(component, props === true ? {} : props, slots) : h(Fragment, {}, slots) };\n};\n","import { computed, defineComponent, h, provide, reactive, onMounted, nextTick, Suspense, Transition } from \"vue\";\nimport { RouterView } from \"vue-router\";\nimport { defu } from \"defu\";\nimport { generateRouteKey, wrapInKeepAlive } from \"./utils.mjs\";\nimport { useNuxtApp } from \"#app\";\nimport { _wrapIf } from \"#app/components/utils\";\nimport { appPageTransition as defaultPageTransition, appKeepalive as defaultKeepaliveConfig } from \"#build/nuxt.config.mjs\";\nexport default defineComponent({\n  name: \"NuxtPage\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String\n    },\n    transition: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    keepalive: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    route: {\n      type: Object\n    },\n    pageKey: {\n      type: [Function, String],\n      default: null\n    }\n  },\n  setup(props, { attrs }) {\n    const nuxtApp = useNuxtApp();\n    return () => {\n      return h(RouterView, { name: props.name, route: props.route, ...attrs }, {\n        default: (routeProps) => {\n          if (!routeProps.Component) {\n            return;\n          }\n          const key = generateRouteKey(props.pageKey, routeProps);\n          const done = nuxtApp.deferHydration();\n          const hasTransition = !!(props.transition ?? routeProps.route.meta.pageTransition ?? defaultPageTransition);\n          const transitionProps = hasTransition && _mergeTransitionProps([\n            props.transition,\n            routeProps.route.meta.pageTransition,\n            defaultPageTransition,\n            { onAfterLeave: () => {\n              nuxtApp.callHook(\"page:transition:finish\", routeProps.Component);\n            } }\n          ].filter(Boolean));\n          return _wrapIf(\n            Transition,\n            hasTransition && transitionProps,\n            wrapInKeepAlive(\n              props.keepalive ?? routeProps.route.meta.keepalive ?? defaultKeepaliveConfig,\n              h(Suspense, {\n                onPending: () => nuxtApp.callHook(\"page:start\", routeProps.Component),\n                onResolve: () => {\n                  nextTick(() => nuxtApp.callHook(\"page:finish\", routeProps.Component).finally(done));\n                }\n              }, { default: () => h(Component, { key, routeProps, pageKey: key, hasTransition }) })\n            )\n          ).default();\n        }\n      });\n    };\n  }\n});\nfunction _toArray(val) {\n  return Array.isArray(val) ? val : val ? [val] : [];\n}\nfunction _mergeTransitionProps(routeProps) {\n  const _props = routeProps.map((prop) => ({\n    ...prop,\n    onAfterLeave: _toArray(prop.onAfterLeave)\n  }));\n  return defu(..._props);\n}\nconst Component = defineComponent({\n  props: [\"routeProps\", \"pageKey\", \"hasTransition\"],\n  setup(props) {\n    const previousKey = props.pageKey;\n    const previousRoute = props.routeProps.route;\n    const route = {};\n    for (const key in props.routeProps.route) {\n      route[key] = computed(() => previousKey === props.pageKey ? props.routeProps.route[key] : previousRoute[key]);\n    }\n    provide(\"_route\", reactive(route));\n    let vnode;\n    if (process.dev && process.client && props.hasTransition) {\n      onMounted(() => {\n        nextTick(() => {\n          if ([\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            const filename = (vnode?.type).__file;\n            console.warn(`[nuxt] \\`${filename}\\` does not have a single root node and will cause errors when navigating between routes.`);\n          }\n        });\n      });\n    }\n    return () => {\n      if (process.dev && process.client) {\n        vnode = h(props.routeProps.Component);\n        return vnode;\n      }\n      return h(props.routeProps.Component);\n    };\n  }\n});\n","import { createSSRApp, createApp, nextTick } from \"vue\";\nimport { $fetch } from \"ohmyfetch\";\nimport { baseURL } from \"#build/paths.mjs\";\nimport { createNuxtApp, applyPlugins, normalizePlugins } from \"#app\";\nimport \"#build/css\";\nimport _plugins from \"#build/plugins\";\nimport RootComponent from \"#build/root-component.mjs\";\nimport AppComponent from \"#build/app-component.mjs\";\nif (!globalThis.$fetch) {\n  globalThis.$fetch = $fetch.create({\n    baseURL: baseURL()\n  });\n}\nlet entry;\nconst plugins = normalizePlugins(_plugins);\nif (process.server) {\n  entry = async function createNuxtAppServer(ssrContext) {\n    const vueApp = createApp(RootComponent);\n    vueApp.component(\"App\", AppComponent);\n    const nuxt = createNuxtApp({ vueApp, ssrContext });\n    try {\n      await applyPlugins(nuxt, plugins);\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n    } catch (err) {\n      await nuxt.callHook(\"app:error\", err);\n      nuxt.payload.error = nuxt.payload.error || err;\n    }\n    return vueApp;\n  };\n}\nif (process.client) {\n  if (process.dev && import.meta.webpackHot) {\n    import.meta.webpackHot.accept();\n  }\n  entry = async function initApp() {\n    const isSSR = Boolean(window.__NUXT__?.serverRendered);\n    const vueApp = isSSR ? createSSRApp(RootComponent) : createApp(RootComponent);\n    vueApp.component(\"App\", AppComponent);\n    const nuxt = createNuxtApp({ vueApp });\n    try {\n      await applyPlugins(nuxt, plugins);\n    } catch (err) {\n      await nuxt.callHook(\"app:error\", err);\n      nuxt.payload.error = nuxt.payload.error || err;\n    }\n    try {\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n      await nuxt.hooks.callHook(\"app:beforeMount\", vueApp);\n      vueApp.mount(\"#__nuxt\");\n      await nuxt.hooks.callHook(\"app:mounted\", vueApp);\n      await nextTick();\n    } catch (err) {\n      await nuxt.callHook(\"app:error\", err);\n      nuxt.payload.error = nuxt.payload.error || err;\n    }\n  };\n  entry().catch((error) => {\n    console.error(\"Error while mounting app:\", error);\n  });\n}\nexport default (ctx) => entry(ctx);\n"],"file":"server.mjs"}